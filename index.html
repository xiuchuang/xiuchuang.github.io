<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
<meta name="msvalidate.01" content="17A55F9509852879F9CD357ED4788B7A" />
<meta name="baidu-site-verification" content="code-3R53OPxtRu" />
<meta name="google-site-verification" content="QFLRBQwJh5H7mRBWzxKk0lyyHubVh-RudJrC9McRk5A" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="彭晨的简单记录">
<meta property="og:type" content="website">
<meta property="og:title" content="Pengchen&#39;s Blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Pengchen&#39;s Blog">
<meta property="og:description" content="彭晨的简单记录">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Peng Chen">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Pengchen's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Pengchen's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">世界无限广阔，好男儿切莫固步自封</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/10/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8-1-%E5%9F%BA%E6%9C%AC%E4%BA%86%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Peng Chen">
      <meta itemprop="description" content="彭晨的简单记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pengchen's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8-1-%E5%9F%BA%E6%9C%AC%E4%BA%86%E8%A7%A3/" class="post-title-link" itemprop="url">分库分表——1. 基本了解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-10-21 10:28:50 / 修改时间：17:30:55" itemprop="dateCreated datePublished" datetime="2020-10-21T10:28:50+08:00">2020-10-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Database/" itemprop="url" rel="index"><span itemprop="name">Database</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>&emsp;&emsp;这篇文章取自<a target="_blank" rel="noopener" href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/database-shard.md">这篇博客</a>，作为整理和收录，方便后续查阅。</p>
<h3 id="为什么要分库分表？"><a href="#为什么要分库分表？" class="headerlink" title="为什么要分库分表？"></a>为什么要分库分表？</h3><p>&emsp;&emsp;说白了，分库分表是两回事儿，大家可别搞混了，可能是光分库不分表，也可能是光分表不分库，都有可能。</p>
<p>&emsp;&emsp;假如我们现在是一个小创业公司（或者是一个 BAT 公司刚兴起的一个新部门），现在注册用户就 20 万，每天活跃用户就 1 万，每天单表数据量就 1000，然后高峰期每秒钟并发请求最多就 10 个。我的天，就这种系统，随便找一个有几年工作经验的，然后带几个刚培训出来的，随便干干都可以。</p>
<p>&emsp;&emsp;结果没想到我们运气居然这么好，碰上个 CEO 带着我们走上了康庄大道，业务发展迅猛，过了几个月，注册用户数达到了 2000 万！每天活跃用户数 100 万！每天单表数据量 10 万条！高峰期每秒最大请求达到 1000！同时公司还顺带着融资了两轮，进账了几个亿人民币啊！公司估值达到了惊人的几亿美金！这是小独角兽的节奏！</p>
<p>&emsp;&emsp;好吧，没事，现在大家感觉压力已经有点大了，为啥呢？因为每天多 10 万条数据，一个月就多 300 万条数据，现在咱们单表已经几百万数据了，马上就破千万了。但是勉强还能撑着。高峰期请求现在是 1000，咱们线上部署了几台机器，负载均衡搞了一下，数据库撑 1000QPS 也还凑合。但是大家现在开始感觉有点担心了，接下来咋整呢……</p>
<p>&emsp;&emsp;再接下来几个月，我的天，CEO 太牛逼了，公司用户数已经达到 1 亿，公司继续融资几十亿人民币啊！公司估值达到了惊人的几十亿美金，成为了国内今年最牛逼的明星创业公司！天，我们太幸运了。</p>
<p>&emsp;&emsp;但是我们同时也是不幸的，因为此时每天活跃用户数上千万，每天单表新增数据多达 50 万，目前一个表总数据量都已经达到了两三千万了！扛不住啊！数据库磁盘容量不断消耗掉！高峰期并发达到惊人的 <code>5000~8000</code> ！别开玩笑了，哥。我跟你保证，你的系统支撑不到现在，已经挂掉了！</p>
<p>&emsp;&emsp;好吧，所以你看到这里差不多就理解分库分表是怎么回事儿了，实际上这是跟着你的公司业务发展走的，你公司业务发展越好，用户就越多，数据量越大，请求量越大，那你单个数据库一定扛不住。</p>
<h4 id="分表"><a href="#分表" class="headerlink" title="分表"></a>分表</h4><p>&emsp;&emsp;比如你单表都几千万数据了，你确定你能扛住么？绝对不行，<strong>单表数据量太大</strong>，会极大影响你的 sql <strong>执行的性能</strong>，到了后面你的 sql 可能就跑的很慢了。一般来说，就以我的经验来看，单表到几百万的时候，性能就会相对差一些了，你就得分表了。</p>
<p>&emsp;&emsp;分表是啥意思？就是把一个表的数据放到多个表中，然后查询的时候你就查一个表。比如按照用户 id 来分表，将一个用户的数据就放在一个表中。然后操作的时候你对一个用户就操作那个表就好了。这样可以控制每个表的数据量在可控的范围内，比如每个表就固定在 200 万以内。</p>
<h4 id="分库"><a href="#分库" class="headerlink" title="分库"></a>分库</h4><p>&emsp;&emsp;分库是啥意思？就是你一个库一般我们经验而言，最多支撑到并发 2000，一定要扩容了，而且一个健康的单库并发值你最好保持在每秒 1000 左右，不要太大。那么你可以将一个库的数据拆分到多个库中，访问的时候就访问一个库好了。</p>
<p>&emsp;&emsp;这就是所谓的<strong>分库分表</strong>，为啥要分库分表？你明白了吧。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:left">分库分表前</th>
<th style="text-align:left">分库分表后</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">并发支撑情况</td>
<td style="text-align:left">MySQL 单机部署，扛不住高并发</td>
<td style="text-align:left">MySQL 从单机到多机，能承受的并发增加了多倍</td>
</tr>
<tr>
<td style="text-align:center">磁盘使用情况</td>
<td style="text-align:left">MySQL 单机磁盘容量几乎撑满</td>
<td style="text-align:left">拆分为多个库，数据库服务器磁盘使用率大大降低</td>
</tr>
<tr>
<td style="text-align:center">SQL 执行性能</td>
<td style="text-align:left">单表数据量太大，SQL 越跑越慢</td>
<td style="text-align:left">单表数据量减少，SQL 执行效率明显提升</td>
</tr>
</tbody>
</table>
</div>
<h3 id="分库分表中间件"><a href="#分库分表中间件" class="headerlink" title="分库分表中间件"></a>分库分表中间件</h3><p>&emsp;&emsp;这个其实就是看看你了解哪些分库分表的中间件，各个中间件的优缺点是啥？然后你用过哪些分库分表的中间件。</p>
<p>比较常见的包括：</p>
<ul>
<li>Cobar</li>
<li>TDDL</li>
<li>Atlas</li>
<li>Sharding-jdbc</li>
<li>Mycat</li>
</ul>
<h4 id="Cobar"><a href="#Cobar" class="headerlink" title="Cobar"></a>Cobar</h4><p>&emsp;&emsp;阿里 b2b 团队开发和开源的，属于 proxy 层方案，就是介于应用服务器和数据库服务器之间。应用程序通过 JDBC 驱动访问 Cobar 集群，Cobar 根据 SQL 和分库规则对 SQL 做分解，然后分发到 MySQL 集群不同的数据库实例上执行。早些年还可以用，但是最近几年都没更新了，基本没啥人用，差不多算是被抛弃的状态吧。而且不支持读写分离、存储过程、跨库 join 和分页等操作。</p>
<h4 id="TDDL"><a href="#TDDL" class="headerlink" title="TDDL"></a>TDDL</h4><p>&emsp;&emsp;淘宝团队开发的，属于 client 层方案。支持基本的 crud 语法和读写分离，但不支持 join、多表查询等语法。目前使用的也不多，因为还依赖淘宝的 diamond 配置管理系统。</p>
<h4 id="Atlas"><a href="#Atlas" class="headerlink" title="Atlas"></a>Atlas</h4><p>&emsp;&emsp;360 开源的，属于 proxy 层方案，以前是有一些公司在用的，但是确实有一个很大的问题就是社区最新的维护都在 5 年前了。所以，现在用的公司基本也很少了。</p>
<h4 id="Sharding-jdbc"><a href="#Sharding-jdbc" class="headerlink" title="Sharding-jdbc"></a>Sharding-jdbc</h4><p>&emsp;&emsp;当当开源的，属于 client 层方案，是<a target="_blank" rel="noopener" href="https://shardingsphere.apache.org/"> <code>ShardingSphere</code> </a>的 client 层方案，<a target="_blank" rel="noopener" href="https://shardingsphere.apache.org/"> <code>ShardingSphere</code> </a>还提供 proxy 层的方案 Sharding-Proxy。确实之前用的还比较多一些，因为 SQL 语法支持也比较多，没有太多限制，而且截至 2019.4，已经推出到了 <code>4.0.0-RC1</code> 版本，支持分库分表、读写分离、分布式 id 生成、柔性事务（最大努力送达型事务、TCC 事务）。而且确实之前使用的公司会比较多一些（这个在官网有登记使用的公司，可以看到从 2017 年一直到现在，是有不少公司在用的），目前社区也还一直在开发和维护，还算是比较活跃，个人认为算是一个现在也<strong>可以选择的方案</strong>。</p>
<h4 id="Mycat"><a href="#Mycat" class="headerlink" title="Mycat"></a>Mycat</h4><p>&emsp;&emsp;基于 Cobar 改造的，属于 proxy 层方案，支持的功能非常完善，而且目前应该是非常火的而且不断流行的数据库中间件，社区很活跃，也有一些公司开始在用了。但是确实相比于 Sharding jdbc 来说，年轻一些，经历的锤炼少一些。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>&emsp;&emsp;综上，现在其实建议考量的，就是 Sharding-jdbc 和 Mycat，这两个都可以去考虑使用。</p>
<p>&emsp;&emsp;Sharding-jdbc 这种 client 层方案的<strong>优点在于不用部署，运维成本低，不需要代理层的二次转发请求，性能很高</strong>，但是如果遇到升级啥的需要各个系统都重新升级版本再发布，各个系统都需要<strong>耦合</strong> Sharding-jdbc 的依赖；</p>
<p>&emsp;&emsp;Mycat 这种 proxy 层方案的<strong>缺点在于需要部署</strong>，自己运维一套中间件，运维成本高，但是<strong>好处在于对于各个项目是透明的</strong>，如果遇到升级之类的都是自己中间件那里搞就行了。</p>
<p>&emsp;&emsp;通常来说，这两个方案其实都可以选用，但是我个人建议中小型公司选用 Sharding-jdbc，client 层方案轻便，而且维护成本低，不需要额外增派人手，而且中小型公司系统复杂度会低一些，项目也没那么多；但是中大型公司最好还是选用 Mycat 这类 proxy 层方案，因为可能大公司系统和项目非常多，团队很大，人员充足，那么最好是专门弄个人来研究和维护 Mycat，然后大量项目直接透明使用即可。</p>
<h3 id="垂直拆分和水平拆分"><a href="#垂直拆分和水平拆分" class="headerlink" title="垂直拆分和水平拆分"></a>垂直拆分和水平拆分</h3><p>&emsp;&emsp;<strong>水平拆分</strong>的意思，就是把一个表的数据给弄到多个库的多个表里去，但是每个库的表结构都一样，只不过每个库表放的数据是不同的，所有库表的数据加起来就是全部数据。水平拆分的意义，就是将数据均匀放更多的库里，然后用多个库来扛更高的并发，还有就是用多个库的存储容量来进行扩容。</p>
<p><a href=""><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/database/database-split-horizon.png" alt="database-split-horizon"></a></p>
<p>&emsp;&emsp;<strong>垂直拆分</strong>的意思，就是<strong>把一个有很多字段的表给拆分成多个表</strong>，<strong>或者是多个库上去</strong>。每个库表的结构都不一样，每个库表都包含部分字段。一般来说，会<strong>将较少的访问频率很高的字段放到一个表里去</strong>，然后<strong>将较多的访问频率很低的字段放到另外一个表里去</strong>。因为数据库是有缓存的，你访问频率高的行字段越少，就可以在缓存里缓存更多的行，性能就越好。这个一般在表层面做的较多一些。</p>
<p><a href=""><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/database/database-split-vertically.png" alt="database-split-vertically"></a></p>
<p>&emsp;&emsp;这个其实挺常见的，不一定我说，大家很多同学可能自己都做过，把一个大表拆开，订单表、订单支付表、订单商品表。</p>
<p>&emsp;&emsp;还有<strong>表层面的拆分</strong>，就是分表，将一个表变成 N 个表，就是<strong>让每个表的数据量控制在一定范围内</strong>，保证 SQL 的性能。否则单表数据量越大，SQL 性能就越差。一般是 200 万行左右，不要太多，但是也得看具体你怎么操作，也可能是 500 万，或者是 100 万。你的 SQL 越复杂，就最好让单表行数越少。</p>
<p>&emsp;&emsp;好了，无论分库还是分表，上面说的那些数据库中间件都是可以支持的。就是基本上那些中间件可以做到你分库分表之后，<strong>中间件可以根据你指定的某个字段值</strong>，比如说 userid，<strong>自动路由到对应的库上去，然后再自动路由到对应的表里去</strong>。</p>
<p>&emsp;&emsp;你就得考虑一下，你的项目里该如何分库分表？一般来说，垂直拆分，你可以在表层面来做，对一些字段特别多的表做一下拆分；水平拆分，你可以说是并发承载不了，或者是数据量太大，容量承载不了，你给拆了，按什么字段来拆，你自己想好；分表，你考虑一下，你如果哪怕是拆到每个库里去，并发和容量都 ok 了，但是每个库的表还是太大了，那么你就分表，将这个表分开，保证每个表的数据量并不是很大。</p>
<p>&emsp;&emsp;而且这儿还有两种<strong>分库分表的方式</strong>：</p>
<ul>
<li>一种是按照 range 来分，就是每个库一段连续的数据，这个一般是按比如<strong>时间范围</strong>来的，但是这种一般较少用，因为很容易产生热点问题，大量的流量都打在最新的数据上了。</li>
<li>或者是按照某个字段 hash 一下均匀分散，这个较为常用。</li>
</ul>
<p>&emsp;&emsp; range 来分，好处在于说，扩容的时候很简单，因为你只要预备好，给每个月都准备一个库就可以了，到了一个新的月份的时候，自然而然，就会写新的库了；缺点，但是大部分的请求，都是访问最新的数据。实际生产用 range，要看场景。</p>
<p>&emsp;&emsp;hash 分发，好处在于说，可以平均分配每个库的数据量和请求压力；坏处在于说扩容起来比较麻烦，会有一个数据迁移的过程，之前的数据需要重新计算 hash 值重新分配到不同的库或表。</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a target="_blank" rel="noopener" href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/database-shard.md">1. database-shard</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/10/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8-2-%E8%BF%81%E7%A7%BB%E6%96%B9%E6%A1%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Peng Chen">
      <meta itemprop="description" content="彭晨的简单记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pengchen's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8-2-%E8%BF%81%E7%A7%BB%E6%96%B9%E6%A1%88/" class="post-title-link" itemprop="url">分库分表——2. 迁移方案</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-10-21 11:51:51 / 修改时间：17:30:47" itemprop="dateCreated datePublished" datetime="2020-10-21T11:51:51+08:00">2020-10-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Database/" itemprop="url" rel="index"><span itemprop="name">Database</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>&emsp;&emsp;这篇文章取自<a target="_blank" rel="noopener" href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/database-shard-method.md">这篇博客</a>，作为整理和收录，方便后续查阅。</p>
<p>&emsp;&emsp;现在有一个未分库分表的系统，未来要分库分表，如何设计才可以让系统从未分库分表<strong>动态切换</strong>到分库分表上？</p>
<h3 id="停机迁移方案"><a href="#停机迁移方案" class="headerlink" title="停机迁移方案"></a>停机迁移方案</h3><p>&emsp;&emsp;我先给你说一个最 low 的方案，就是很简单，大家伙儿凌晨 12 点开始运维，网站或者 app 挂个公告，说 0 点到早上 6 点进行运维，无法访问。</p>
<p>&emsp;&emsp;接着到 0 点停机，系统停掉，没有流量写入了，此时老的单库单表数据库静止了。然后你之前得写好一个<strong>导数的一次性工具</strong>，此时直接跑起来，然后将单库单表的数据哗哗哗读出来，写到分库分表里面去。</p>
<p>&emsp;&emsp;导数完了之后，就 ok 了，修改系统的数据库连接配置啥的，包括可能代码和 SQL 也许有修改，那你就用最新的代码，然后直接启动连到新的分库分表上去。</p>
<p>&emsp;&emsp;验证一下，ok 了，完美，大家伸个懒腰，看看看凌晨 4 点钟的北京夜景，打个滴滴回家吧。</p>
<p>&emsp;&emsp;但是这个方案比较 low，谁都能干，我们来看看高大上一点的方案。</p>
<p><a href=""><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/database/database-shard-method-1.png" alt="database-shard-method-1"></a></p>
<h3 id="双写迁移方案"><a href="#双写迁移方案" class="headerlink" title="双写迁移方案"></a>双写迁移方案</h3><p>&emsp;1. 将新的库配置为源库的从库用来同步数据；如果需要将数据同步到多库多表，那么可以使用一些第三方工具获取 Binlog 的增量日志（比如开源工具 Canal），在获取增量日志之后就可以按照分库分表的逻辑写入到新的库表中了。</p>
<p>&emsp;2. 同时我们需要改造业务代码，在数据写入的时候不仅要写入旧库也要写入新库。当然，基于性能的考虑，我们可以异步地写入新库，只要保证旧库写入成功即可。但是我们需要注意的是，需要将写入新库失败的数据记录在单独的日志中，这样方便后续对这些数据补写，保证新库和旧库的数据一致性。</p>
<p>&emsp;3. 然后我们就可以开始校验数据了。由于数据库中数据量很大，做全量的数据校验不太现实。你可以抽取部分数据，具体数据量依据总体数据量而定，只要保证这些数据是一致的就可以。</p>
<p>&emsp;4. 双写时加开关，默认关闭双写，上线完成后关闭同步，同时打开开关，在低峰期的话数据丢失的概率不高。再配合数据校验的工作，是可以保证一致性的。</p>
<p>&emsp;5. 如果一切顺利，我们就可以将读流量切换到新库了。由于担心一次切换全量读流量可能会对系统产生未知的影响，所以这里最好采用灰度的方式来切换，比如开始切换 10% 的流量，如果没有问题再切换到 50% 的流量，最后再切换到 100%。</p>
<p>&emsp;6. 由于有双写的存在，所以在切换的过程中出现任何的问题都可以将读写流量随时切换到旧库去，保障系统的性能。</p>
<p>&emsp;7. 在观察了几天发现数据的迁移没有问题之后，就可以将数据库的双写改造成只写新库，数据的迁移也就完成了。</p>
<p><a href=""><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/database/database-shard-method-2.webp" alt="database-shard-method-2"></a></p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a target="_blank" rel="noopener" href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/database-shard-method.md">1. database-shard-method</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/ab2efddfafbd">2. 数据迁移之同步双写方案</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/10/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8-3-%E5%8A%A8%E6%80%81%E6%89%A9%E5%AE%B9%E7%BC%A9%E5%AE%B9%E6%96%B9%E6%A1%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Peng Chen">
      <meta itemprop="description" content="彭晨的简单记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pengchen's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8-3-%E5%8A%A8%E6%80%81%E6%89%A9%E5%AE%B9%E7%BC%A9%E5%AE%B9%E6%96%B9%E6%A1%88/" class="post-title-link" itemprop="url">分库分表——3. 动态扩容缩容方案</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-10-21 14:39:21 / 修改时间：17:30:34" itemprop="dateCreated datePublished" datetime="2020-10-21T14:39:21+08:00">2020-10-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Database/" itemprop="url" rel="index"><span itemprop="name">Database</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>&emsp;&emsp;这篇文章取自<a target="_blank" rel="noopener" href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/database-shard-dynamic-expand.md">这篇博客</a>，作为整理和收录，方便后续查阅。</p>
<h3 id="停机扩容（不推荐）"><a href="#停机扩容（不推荐）" class="headerlink" title="停机扩容（不推荐）"></a>停机扩容（不推荐）</h3><p>&emsp;&emsp;这个方案就跟停机迁移一样，步骤几乎一致，唯一的一点就是那个导数的工具，是把现有库表的数据抽出来慢慢倒入到新的库和表里去。但是最好别这么玩儿，有点不太靠谱，因为既然<strong>分库分表</strong>就说明数据量实在是太大了，可能多达几亿条，甚至几十亿，你这么玩儿，可能会出问题。</p>
<p>&emsp;&emsp;从单库单表迁移到分库分表的时候，数据量并不是很大，单表最大也就两三千万。那么你写个工具，多弄几台机器并行跑，1 小时数据就导完了。这没有问题。</p>
<p>&emsp;&emsp;如果 3 个库 + 12 个表，跑了一段时间了，数据量都 1~2 亿了。光是导 2 亿数据，都要导个几个小时，6 点，刚刚导完数据，还要搞后续的修改配置，重启系统，测试验证，10 点才可以搞完。所以不能这么搞。</p>
<h3 id="优化后的方案"><a href="#优化后的方案" class="headerlink" title="优化后的方案"></a>优化后的方案</h3><p>&emsp;&emsp;一开始上来就是 32 个库，每个库 32 个表，那么总共是 1024 张表。</p>
<p>&emsp;&emsp;这个分法，第一，基本上国内的互联网肯定都是够用了，第二，无论是并发支撑还是数据量支撑都没问题。</p>
<p>&emsp;&emsp;每个库正常承载的写入并发量是 1000，那么 32 个库就可以承载 32 <em> 1000 = 32000 的写并发，如果每个库承载 1500 的写并发，32 </em> 1500 = 48000 的写并发，接近 5 万每秒的写入并发，前面再加一个 MQ，削峰，每秒写入 MQ 8 万条数据，每秒消费 5 万条数据。</p>
<p>&emsp;&emsp;有些除非是国内排名非常靠前的这些公司，他们的最核心的系统的数据库，可能会出现几百台数据库的这么一个规模，128 个库，256 个库，512 个库。</p>
<p>&emsp;&emsp;1024 张表，假设每个表放 500 万数据，在 MySQL 里可以放 50 亿条数据。</p>
<p>&emsp;&emsp;每秒 5 万的写并发，总共 50 亿条数据，对于国内大部分的互联网公司来说，其实一般来说都够了。</p>
<p>&emsp;&emsp;谈分库分表的扩容，<strong>第一次分库分表，就一次性给他分个够</strong>，32 个库，1024 张表，可能对大部分的中小型互联网公司来说，已经可以支撑好几年了。</p>
<p>&emsp;&emsp;一个实践是利用 <code>32 * 32</code> 来分库分表，即分为 32 个库，每个库里一个表分为 32 张表。一共就是 1024 张表。根据某个 id 先根据 32 取模路由到库，再根据 32 取模路由到库里的表。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>orderId</th>
<th>id % 32 (库)</th>
<th>id / 32 % 32 (表)</th>
</tr>
</thead>
<tbody>
<tr>
<td>259</td>
<td>3</td>
<td>8</td>
</tr>
<tr>
<td>1189</td>
<td>5</td>
<td>5</td>
</tr>
<tr>
<td>352</td>
<td>0</td>
<td>11</td>
</tr>
<tr>
<td>4593</td>
<td>17</td>
<td>15</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;&emsp;刚开始的时候，这个库可能就是逻辑库，建在一个数据库上的，就是一个 MySQL 服务器可能建了 n 个库，比如 32 个库。后面如果要拆分，就是不断在库和 MySQL 服务器之间做迁移就可以了。然后系统配合改一下配置即可。</p>
<p>&emsp;&emsp;比如说最多可以扩展到 32 个数据库服务器，每个数据库服务器是一个库。如果还是不够？最多可以扩展到 1024 个数据库服务器，每个数据库服务器上面一个库一个表。因为最多是 1024 个表。</p>
<p>&emsp;&emsp;这么搞，是不用自己写代码做数据迁移的，都交给 DBA 来搞好了，但是 DBA 确实是需要做一些库表迁移的工作，但是总比你自己写代码，然后抽数据导数据来的效率高得多吧。</p>
<p>&emsp;&emsp;哪怕是要减少库的数量，也很简单，其实说白了就是按倍数缩容就可以了，然后修改一下路由规则。</p>
<p>&emsp;&emsp;这里对步骤做一个总结：</p>
<ol>
<li>设定好几台数据库服务器，每台服务器上几个库，每个库多少个表，推荐是 32 库 * 32 表，对于大部分公司来说，可能几年都够了。</li>
<li>路由的规则，orderId 模 32 = 库，orderId / 32 模 32 = 表。</li>
<li>扩容的时候，申请增加更多的数据库服务器，装好 MySQL，呈倍数扩容，4 台服务器，扩到 8 台服务器，再到 16 台服务器。</li>
<li>由 DBA 负责将原先数据库服务器的库，迁移到新的数据库服务器上去，库迁移是有一些便捷的工具的。</li>
<li>我们这边就是修改一下配置，调整迁移的库所在数据库服务器的地址。</li>
<li>重新发布系统，上线，原先的路由规则变都不用变，直接可以基于 n 倍的数据库服务器的资源，继续进行线上系统的提供服务。</li>
</ol>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a target="_blank" rel="noopener" href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/database-shard-dynamic-expand.md">1. database-shard-dynamic-expand</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/10/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8-4-%E4%B8%BB%E9%94%AE%E7%94%9F%E6%88%90%E7%AD%96%E7%95%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Peng Chen">
      <meta itemprop="description" content="彭晨的简单记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pengchen's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8-4-%E4%B8%BB%E9%94%AE%E7%94%9F%E6%88%90%E7%AD%96%E7%95%A5/" class="post-title-link" itemprop="url">分库分表——4. 主键生成策略</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-10-21 16:45:22 / 修改时间：17:29:47" itemprop="dateCreated datePublished" datetime="2020-10-21T16:45:22+08:00">2020-10-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Database/" itemprop="url" rel="index"><span itemprop="name">Database</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>&emsp;&emsp;这篇文章取自<a target="_blank" rel="noopener" href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/database-shard-global-id-generate.md">这篇博客</a>，作为整理和收录，方便后续查阅。</p>
<h3 id="基于数据库的实现方案"><a href="#基于数据库的实现方案" class="headerlink" title="基于数据库的实现方案"></a>基于数据库的实现方案</h3><h4 id="数据库自增-id"><a href="#数据库自增-id" class="headerlink" title="数据库自增 id"></a>数据库自增 id</h4><p>&emsp;&emsp;这个就是说你的系统里每次得到一个 id，都是往一个库的一个表里插入一条没什么业务含义的数据，然后获取一个数据库自增的一个 id。拿到这个 id 之后再往对应的分库分表里去写入。</p>
<p>&emsp;&emsp;这个方案的好处就是方便简单，谁都会用；<strong>缺点就是单库生成</strong>自增 id，要是高并发的话，就会有瓶颈的；如果你硬是要改进一下，那么就专门开一个服务出来，这个服务每次就拿到当前 id 最大值，然后自己递增几个 id，一次性返回一批 id，然后再把当前最大 id 值修改成递增几个 id 之后的一个值；但是<strong>无论如何都是基于单个数据库</strong>。</p>
<p><strong>&emsp;&emsp;适合的场景</strong>：你分库分表就俩原因，要不就是单库并发太高，要不就是单库数据量太大；除非是你<strong>并发不高，但是数据量太大</strong>导致的分库分表扩容，你可以用这个方案，因为可能每秒最高并发最多就几百，那么就走单独的一个库和表生成自增主键即可。</p>
<h4 id="设置数据库-sequence-或者表自增字段步长"><a href="#设置数据库-sequence-或者表自增字段步长" class="headerlink" title="设置数据库 sequence 或者表自增字段步长"></a>设置数据库 sequence 或者表自增字段步长</h4><p>&emsp;&emsp;可以通过设置数据库 sequence 或者表的自增字段步长来进行水平伸缩。</p>
<p>&emsp;&emsp;比如说，现在有 8 个服务节点，每个服务节点使用一个 sequence 功能来产生 ID，每个 sequence 的起始 ID 不同，并且依次递增，步长都是 8。</p>
<p><a href=""><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/database/database-id-sequence-step.png" alt="database-id-sequence-step"></a></p>
<p><strong>&emsp;&emsp;适合的场景</strong>：在用户防止产生的 ID 重复时，这种方案实现起来比较简单，也能达到性能目标。但是服务节点固定，步长也固定，将来如果还要增加服务节点，就不好搞了。</p>
<h3 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h3><p>&emsp;&emsp;好处就是本地生成，不要基于数据库来了；不好之处就是，UUID 太长了、占用空间大，<strong>作为主键性能太差</strong>了；更重要的是，UUID 不具有有序性，会导致 B+ 树索引在写的时候有过多的随机写操作（连续的 ID 可以产生部分顺序写），还有，由于在写的时候不能产生有顺序的 append 操作，而需要进行 insert 操作，将会读取整个 B+ 树节点到内存，在插入这条记录后会将整个节点写回磁盘，这种操作在记录占用空间比较大的情况下，性能下降明显。</p>
<p>&emsp;&emsp;适合的场景：如果你是要随机生成个什么文件名、编号之类的，你可以用 UUID，但是作为主键是不能用 UUID 的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;) -&gt; sfsdf23423rr234sfdaf</span><br></pre></td></tr></table></figure>
<h3 id="获取系统当前时间"><a href="#获取系统当前时间" class="headerlink" title="获取系统当前时间"></a>获取系统当前时间</h3><p>&emsp;&emsp;这个就是获取当前时间即可，但是问题是，<strong>并发很高的时候</strong>，比如一秒并发几千，<strong>会有重复的情况</strong>，这个是肯定不合适的。基本就不用考虑了。</p>
<p>&emsp;&emsp;适合的场景：一般如果用这个方案，是将当前时间跟很多其他的业务字段拼接起来，作为一个 id，如果业务上你觉得可以接受，那么也是可以的。你可以将别的业务字段值跟当前时间拼接起来，组成一个全局唯一的编号。</p>
<h3 id="snowflake-算法"><a href="#snowflake-算法" class="headerlink" title="snowflake 算法"></a>snowflake 算法</h3><p>&emsp;&emsp;snowflake 算法是 twitter 开源的分布式 id 生成算法，采用 Scala 语言实现，是把一个 64 位的 long 型的 id，1 个 bit 是不用的，用其中的 41 bits 作为毫秒数，用 10 bits 作为工作机器 id，12 bits 作为序列号。</p>
<ul>
<li>1 bit：不用，为啥呢？因为二进制里第一个 bit 为如果是 1，那么都是负数，但是我们生成的 id 都是正数，所以第一个 bit 统一都是 0。</li>
<li>41 bits：表示的是时间戳，单位是毫秒。41 bits 可以表示的数字多达 <code>2^41 - 1</code> ，也就是可以标识 <code>2^41 - 1</code> 个毫秒值，换算成年就是表示 69 年的时间。</li>
<li>10 bits：记录工作机器 id，代表的是这个服务最多可以部署在 2^10 台机器上，也就是 1024 台机器。但是 10 bits 里 5 个 bits 代表机房 id，5 个 bits 代表机器 id。意思就是最多代表 <code>2^5</code> 个机房（32 个机房），每个机房里可以代表 <code>2^5</code> 个机器（32 台机器）。</li>
<li>12 bits：这个是用来记录同一个毫秒内产生的不同 id，12 bits 可以代表的最大正整数是 <code>2^12 - 1 = 4096</code> ，也就是说可以用这个 12 bits 代表的数字来区分<strong>同一个毫秒内</strong>的 4096 个不同的 id。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> | <span class="number">0001100</span> <span class="number">10100010</span> <span class="number">10111110</span> <span class="number">10001001</span> <span class="number">01011100</span> <span class="number">00</span> | <span class="number">10001</span> | <span class="number">1</span> <span class="number">1001</span> | <span class="number">0000</span> <span class="number">00000000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdWorker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> workerId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> datacenterId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> sequence;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IdWorker</span><span class="params">(<span class="keyword">long</span> workerId, <span class="keyword">long</span> datacenterId, <span class="keyword">long</span> sequence)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// sanity check for workerId</span></span><br><span class="line">        <span class="comment">// 这儿不就检查了一下，要求就是你传递进来的机房id和机器id不能超过32，不能小于0</span></span><br><span class="line">        <span class="keyword">if</span> (workerId &gt; maxWorkerId || workerId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    String.format(<span class="string">&quot;worker Id can&#x27;t be greater than %d or less than 0&quot;</span>, maxWorkerId));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (datacenterId &gt; maxDatacenterId || datacenterId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    String.format(<span class="string">&quot;datacenter Id can&#x27;t be greater than %d or less than 0&quot;</span>, maxDatacenterId));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printf(</span><br><span class="line">                <span class="string">&quot;worker starting. timestamp left shift %d, datacenter id bits %d, worker id bits %d, sequence bits %d, workerid %d&quot;</span>,</span><br><span class="line">                timestampLeftShift, datacenterIdBits, workerIdBits, sequenceBits, workerId);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.workerId = workerId;</span><br><span class="line">        <span class="keyword">this</span>.datacenterId = datacenterId;</span><br><span class="line">        <span class="keyword">this</span>.sequence = sequence;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> twepoch = <span class="number">1288834974657L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> workerIdBits = <span class="number">5L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> datacenterIdBits = <span class="number">5L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个是二进制运算，就是 5 bit最多只能有31个数字，也就是说机器id最多只能是32以内</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> maxWorkerId = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; workerIdBits);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个是一个意思，就是 5 bit最多只能有31个数字，机房id最多只能是32以内</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> maxDatacenterId = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; datacenterIdBits);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> sequenceBits = <span class="number">12L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> workerIdShift = sequenceBits;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> datacenterIdShift = sequenceBits + workerIdBits;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> sequenceMask = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; sequenceBits);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> lastTimestamp = -<span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getWorkerId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> workerId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDatacenterId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> datacenterId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getTimestamp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">nextId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这儿就是获取当前时间戳，单位是毫秒</span></span><br><span class="line">        <span class="keyword">long</span> timestamp = timeGen();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (timestamp &lt; lastTimestamp) &#123;</span><br><span class="line">            System.err.printf(<span class="string">&quot;clock is moving backwards.  Rejecting requests until %d.&quot;</span>, lastTimestamp);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(String.format(</span><br><span class="line">                    <span class="string">&quot;Clock moved backwards.  Refusing to generate id for %d milliseconds&quot;</span>, lastTimestamp - timestamp));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (lastTimestamp == timestamp) &#123;</span><br><span class="line">            <span class="comment">// 这个意思是说一个毫秒内最多只能有4096个数字</span></span><br><span class="line">            <span class="comment">// 无论你传递多少进来，这个位运算保证始终就是在4096这个范围内，避免你自己传递个sequence超过了4096这个范围</span></span><br><span class="line">            sequence = (sequence + <span class="number">1</span>) &amp; sequenceMask;</span><br><span class="line">            <span class="keyword">if</span> (sequence == <span class="number">0</span>) &#123;</span><br><span class="line">                timestamp = tilNextMillis(lastTimestamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sequence = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这儿记录一下最近一次生成id的时间戳，单位是毫秒</span></span><br><span class="line">        lastTimestamp = timestamp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这儿就是将时间戳左移，放到 41 bit那儿；</span></span><br><span class="line">        <span class="comment">// 将机房 id左移放到 5 bit那儿；</span></span><br><span class="line">        <span class="comment">// 将机器id左移放到5 bit那儿；将序号放最后12 bit；</span></span><br><span class="line">        <span class="comment">// 最后拼接起来成一个 64 bit的二进制数字，转换成 10 进制就是个 long 型</span></span><br><span class="line">        <span class="keyword">return</span> ((timestamp - twepoch) &lt;&lt; timestampLeftShift) | (datacenterId &lt;&lt; datacenterIdShift)</span><br><span class="line">                | (workerId &lt;&lt; workerIdShift) | sequence;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">tilNextMillis</span><span class="params">(<span class="keyword">long</span> lastTimestamp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> timestamp = timeGen();</span><br><span class="line">        <span class="keyword">while</span> (timestamp &lt;= lastTimestamp) &#123;</span><br><span class="line">            timestamp = timeGen();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> timestamp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">timeGen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ---------------测试---------------</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IdWorker worker = <span class="keyword">new</span> IdWorker(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">            System.out.println(worker.nextId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;怎么说呢，大概这个意思吧，就是说 41 bit 是当前毫秒单位的一个时间戳，就这意思；然后 5 bit 是你传递进来的一个<strong>机房</strong> id（但是最大只能是 32 以内），另外 5 bit 是你传递进来的<strong>机器</strong> id（但是最大只能是 32 以内），剩下的那个 12 bit 序列号，就是如果跟你上次生成 id 的时间还在一个毫秒内，那么会把顺序给你累加，最多在 4096 个序号以内。</p>
<p>&emsp;&emsp;所以你自己利用这个工具类，自己搞一个服务，然后对每个机房的每个机器都初始化这么一个东西，刚开始这个机房的这个机器的序号就是 0。然后每次接收到一个请求，说这个机房的这个机器要生成一个 id，你就找到对应的 Worker 生成。</p>
<p>&emsp;&emsp;利用这个 snowflake 算法，你可以开发自己公司的服务，甚至对于机房 id 和机器 id，反正给你预留了 5 bit + 5 bit，你换成别的有业务含义的东西也可以的。</p>
<p>&emsp;&emsp;这个 snowflake 算法相对来说还是比较靠谱的，所以你要真是搞分布式 id 生成，如果是高并发啥的，那么用这个应该性能比较好，一般每秒几万并发的场景，也足够你用了。</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a target="_blank" rel="noopener" href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/database-shard-global-id-generate.md">1. database-shard-global-id-generate</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/10/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8-5-%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Peng Chen">
      <meta itemprop="description" content="彭晨的简单记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pengchen's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8-5-%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/" class="post-title-link" itemprop="url">分库分表——5. 读写分离</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-10-21 19:03:26 / 修改时间：19:29:03" itemprop="dateCreated datePublished" datetime="2020-10-21T19:03:26+08:00">2020-10-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Database/" itemprop="url" rel="index"><span itemprop="name">Database</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>&emsp;&emsp;这篇文章取自<a target="_blank" rel="noopener" href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/mysql-read-write-separation.md">这篇博客</a>，作为整理和收录，方便后续查阅。</p>
<h3 id="实现-MySQL-读写分离"><a href="#实现-MySQL-读写分离" class="headerlink" title="实现 MySQL 读写分离"></a>实现 MySQL 读写分离</h3><p>&emsp;&emsp;其实很简单，就是基于主从复制架构，简单来说，就搞一个主库，挂多个从库，然后我们就单单只是写主库，然后主库会自动把数据给同步到从库上去。</p>
<h3 id="MySQL-主从复制原理"><a href="#MySQL-主从复制原理" class="headerlink" title="MySQL 主从复制原理"></a>MySQL 主从复制原理</h3><p>&emsp;&emsp;主库将变更写入 binlog 日志，然后从库连接到主库之后，从库有一个 IO 线程，将主库的 binlog 日志拷贝到自己本地，写入一个 relay 中继日志中。接着从库中有一个 SQL 线程会从中继日志读取 binlog，然后执行 binlog 日志中的内容，也就是在自己本地再次执行一遍 SQL，这样就可以保证自己跟主库的数据是一样的。</p>
<p><a href=""><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/database/mysql-master-slave.png" alt="mysql-master-slave"></a></p>
<p>&emsp;&emsp;这里有一个非常重要的一点，就是从库同步主库数据的过程是串行化的，也就是说主库上并行的操作，在从库上会串行执行。所以这就是一个非常重要的点了，由于从库从主库拷贝日志以及串行执行 SQL 的特点，在高并发场景下，从库的数据一定会比主库慢一些，是<strong>有延时</strong>的。所以经常出现，刚写入主库的数据可能是读不到的，要过几十毫秒，甚至几百毫秒才能读取到。</p>
<p>&emsp;&emsp;而且这里还有另外一个问题，就是如果主库突然宕机，然后恰好数据还没同步到从库，那么有些数据可能在从库上是没有的，有些数据可能就丢失了。</p>
<p>&emsp;&emsp;所以 MySQL 实际上在这一块有两个机制，一个是<strong>半同步复制</strong>，用来解决主库数据丢失问题；一个是<strong>并行复制</strong>，用来解决主从同步延时问题。</p>
<p>&emsp;&emsp;这个所谓<strong>半同步复制</strong>，也叫 <code>semi-sync</code> 复制，指的就是主库写入 binlog 日志之后，就会将<strong>强制</strong>此时立即将数据同步到从库，从库将日志写入自己本地的 relay log 之后，接着会返回一个 ack 给主库，主库接收到<strong>至少一个从库</strong>的 ack 之后才会认为写操作完成了。</p>
<p>&emsp;&emsp;所谓<strong>并行复制</strong>，指的是从库开启多个线程，并行读取 relay log 中不同库的日志，然后<strong>并行重放不同库的日志</strong>，这是库级别的并行。</p>
<h3 id="MySQL-主从同步延时问题（精华）"><a href="#MySQL-主从同步延时问题（精华）" class="headerlink" title="MySQL 主从同步延时问题（精华）"></a>MySQL 主从同步延时问题（精华）</h3><p>&emsp;&emsp;以前线上确实处理过因为主从同步延时问题而导致的线上的 bug，属于小型的生产事故。</p>
<p>&emsp;&emsp;是这个么场景。有个同学是这样写代码逻辑的。先插入一条数据，再把它查出来，然后更新这条数据。在生产环境高峰期，写并发达到了 2000/s，这个时候，主从复制延时大概是在小几十毫秒。线上会发现，每天总有那么一些数据，我们期望更新一些重要的数据状态，但在高峰期时候却没更新。用户跟客服反馈，而客服就会反馈给我们。</p>
<p>&emsp;&emsp;我们通过 MySQL 命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show status</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;查看 <code>Seconds_Behind_Master</code> ，可以看到从库复制主库的数据落后了几 ms。</p>
<p>&emsp;&emsp;一般来说，如果主从延迟较为严重，有以下解决方案：</p>
<ul>
<li>分库，将一个主库拆分为多个主库，每个主库的写并发就减少了几倍，此时主从延迟可以忽略不计。</li>
<li>打开 MySQL 支持的并行复制，多个库并行复制。如果说某个库的写入并发就是特别高，单库写并发达到了 2000/s，并行复制还是没意义。</li>
<li>重写代码，写代码的同学，要慎重，插入数据时立马查询可能查不到。</li>
<li>如果确实是存在必须先插入，立马要求就查询到，然后立马就要反过来执行一些操作，对这个查询<strong>设置直连主库</strong>。<strong>不推荐</strong>这种方法，你要是这么搞，读写分离的意义就丧失了。</li>
</ul>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a target="_blank" rel="noopener" href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/mysql-read-write-separation.md">1. mysql-read-write-separation</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/10/30/Zookeeper-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Peng Chen">
      <meta itemprop="description" content="彭晨的简单记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pengchen's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/30/Zookeeper-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/" class="post-title-link" itemprop="url">Zookeeper——使用场景</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-10-30 10:14:20 / 修改时间：10:24:03" itemprop="dateCreated datePublished" datetime="2020-10-30T10:14:20+08:00">2020-10-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Zookeeper/" itemprop="url" rel="index"><span itemprop="name">Zookeeper</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&emsp;&emsp;这篇文章取自<a target="_blank" rel="noopener" href="https://github.com/doocs/advanced-java/blob/master/docs/distributed-system/zookeeper-application-scenarios.md">这篇博客</a>，作为整理和收录，方便后续查阅。</p>
<p>&emsp;&emsp;大致来说，zookeeper 的使用场景如下，举几个简单的：</p>
<ul>
<li>分布式协调</li>
<li>分布式锁</li>
<li>元数据/配置信息管理</li>
<li>HA 高可用性</li>
</ul>
<h3 id="分布式协调"><a href="#分布式协调" class="headerlink" title="分布式协调"></a>分布式协调</h3><p>&emsp;&emsp;这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。那 A 系统如何知道 B 系统的处理结果？用 zookeeper 就可以实现分布式系统之间的协调工作。A 系统发送请求之后可以在 zookeeper 上<strong>对某个节点的值注册个监听器</strong>，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。</p>
<p><a href=""><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Zookeeper/zookeeper-distributed-coordination.png" alt="zookeeper-distributed-coordination"></a></p>
<h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>&emsp;&emsp;举个栗子。对某一个数据连续发出两个修改操作，两台机器同时收到了请求，但是只能一台机器先执行完另外一个机器再执行。那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；然后另外一个机器也<strong>尝试去创建</strong>那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。</p>
<p><a href=""><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Zookeeper/zookeeper-distributed-lock-demo.png" alt="zookeeper-distributed-lock-demo"></a></p>
<h3 id="元数据-配置信息管理"><a href="#元数据-配置信息管理" class="headerlink" title="元数据/配置信息管理"></a>元数据/配置信息管理</h3><p>&emsp;&emsp;zookeeper 可以用作很多系统的配置信息的管理，比如 kafka、storm 等等很多分布式系统都会选用 zookeeper 来做一些元数据、配置信息的管理，包括 dubbo 注册中心不也支持 zookeeper 么？</p>
<p><a href=""><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Zookeeper/zookeeper-meta-data-manage.png" alt="zookeeper-meta-data-manage"></a></p>
<h3 id="HA-高可用性"><a href="#HA-高可用性" class="headerlink" title="HA 高可用性"></a>HA 高可用性</h3><p>&emsp;&emsp;这个应该是很常见的，比如 hadoop、hdfs、yarn 等很多大数据系统，都选择基于 zookeeper 来开发 HA 高可用机制，就是一个<strong>重要进程一般会做主备</strong>两个，主进程挂了立马通过 zookeeper 感知到切换到备用进程。</p>
<p><a href=""><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Zookeeper/zookeeper-active-standby.png" alt="zookeeper-active-standby"></a></p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a target="_blank" rel="noopener" href="https://github.com/doocs/advanced-java/blob/master/docs/distributed-system/zookeeper-application-scenarios.md">1. zookeeper-application-scenarios</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/10/25/%E5%88%86%E5%B8%83%E5%BC%8F-%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86-1-CAP%E5%AE%9A%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Peng Chen">
      <meta itemprop="description" content="彭晨的简单记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pengchen's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/25/%E5%88%86%E5%B8%83%E5%BC%8F-%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86-1-CAP%E5%AE%9A%E7%90%86/" class="post-title-link" itemprop="url">分布式系统原理——1. CAP定理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-10-25 10:32:18 / 修改时间：10:57:48" itemprop="dateCreated datePublished" datetime="2020-10-25T10:32:18+08:00">2020-10-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&emsp;&emsp;这篇文章取自<a target="_blank" rel="noopener" href="https://github.com/doocs/advanced-java/blob/master/docs/distributed-system/distributed-system-cap.md">这篇博客</a>，作为整理和收录，方便后续查阅。</p>
<h3 id="分布式系统-CAP-定理-P-代表什么含义"><a href="#分布式系统-CAP-定理-P-代表什么含义" class="headerlink" title="分布式系统 CAP 定理 P 代表什么含义"></a>分布式系统 CAP 定理 P 代表什么含义</h3><p>&emsp;&emsp;作者之前在看 CAP 定理时抱有很大的疑惑，CAP 定理的定义是指在分布式系统中三者只能满足其二，也就是存在分布式 CA 系统的。作者在网络上查阅了很多关于 CAP 文章，虽然这些文章对于 P 的解释五花八门，但总结下来这些观点大多都是指 P 是不可缺少的，也就是说在分布式系统只能是 AP 或者 CP，这种理论与我之前所认识的理论（存在分布式 CA 系统）是冲突的，所以才有了疑惑。</p>
<blockquote>
<p>这个定理起源于加州大学柏克莱分校（University of California, Berkeley）的计算机科学家埃里克·布鲁尔在 2000 年的分布式计算原理研讨会（PODC）上提出的一个猜想。 在 2002 年，麻省理工学院（MIT）的赛斯·吉尔伯特和南希·林奇发表了布鲁尔猜想的证明，使之成为一个定理。</p>
</blockquote>
<h4 id="什么是-CAP-定理（CAP-theorem）"><a href="#什么是-CAP-定理（CAP-theorem）" class="headerlink" title="什么是 CAP 定理（CAP theorem）"></a>什么是 CAP 定理（CAP theorem）</h4><p>&emsp;&emsp;在理论计算机科学中，CAP 定理（CAP theorem），又被称作布鲁尔定理（Brewer’s theorem），它指出对于一个分布式计算系统来说，不可能同时满足以下三点：</p>
<ul>
<li>一致性（Consistency） （等同于所有节点访问同一份最新的数据副本）</li>
<li>可用性（Availability）（每次请求都能获取到非错的响应——但是不保证获取的数据为最新数据）</li>
<li>分区容错性（Partition tolerance）（以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在 C 和 A 之间做出选择。）</li>
</ul>
<h4 id="分区容错性（Partition-tolerance）"><a href="#分区容错性（Partition-tolerance）" class="headerlink" title="分区容错性（Partition tolerance）"></a>分区容错性（Partition tolerance）</h4><p>&emsp;&emsp;理解 CAP 理论的最简单方式是想象两个节点分处分区两侧。允许至少一个节点更新状态会导致数据不一致，即丧失了 C 性质。如果为了保证数据一致性，将分区一侧的节点设置为不可用，那么又丧失了 A 性质。除非两个节点可以互相通信，才能既保证 C 又保证 A，这又会导致丧失 P 性质。</p>
<ul>
<li>P 指的是分区容错性，分区现象产生后需要容错，容错是指在 A 与 C 之间选择。如果分布式系统没有分区现象（没有出现不一致不可用情况） 本身就没有分区 ，既然没有分区则就更没有分区容错性 P。</li>
<li>无论我设计的系统是 AP 还是 CP 系统如果没有出现不一致不可用。 则该系统就处于 CA 状态</li>
<li>P 的体现前提是得有分区情况存在</li>
</ul>
<blockquote>
<p>文章来源：<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/CAP定理">维基百科 CAP 定理</a></p>
</blockquote>
<h3 id="几个常用的-CAP-框架对比"><a href="#几个常用的-CAP-框架对比" class="headerlink" title="几个常用的 CAP 框架对比"></a>几个常用的 CAP 框架对比</h3><div class="table-container">
<table>
<thead>
<tr>
<th>框架</th>
<th>所属</th>
</tr>
</thead>
<tbody>
<tr>
<td>Eureka</td>
<td>AP</td>
</tr>
<tr>
<td>Zookeeper</td>
<td>CP</td>
</tr>
<tr>
<td>Consul</td>
<td>CP</td>
</tr>
</tbody>
</table>
</div>
<h4 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h4><blockquote>
<p>Eureka 保证了可用性，实现最终一致性。</p>
</blockquote>
<p>&emsp;&emsp;Eureka 所有节点都是平等的所有数据都是相同的，且 Eureka 可以相互交叉注册。<br>&emsp;&emsp;Eureka client 使用内置轮询负载均衡器去注册，有一个检测间隔时间，如果在一定时间内没有收到心跳，才会移除该节点注册信息；如果客户端发现当前 Eureka 不可用，会切换到其他的节点，如果所有的 Eureka 都跪了，Eureka client 会使用最后一次数据作为本地缓存；所以以上的每种设计都是他不具备<code>一致性</code>的特性。</p>
<p>&emsp;&emsp;注意：因为 Eureka AP 的特性和请求间隔同步机制，在服务更新时候一般会手动通过 Eureka 的 api 把当前服务状态设置为<code>offline</code>，并等待 2 个同步间隔后重新启动，这样就能保证服务更新节点对整体系统的影响。</p>
<h4 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h4><blockquote>
<p>强一致性</p>
</blockquote>
<p>&emsp;&emsp;Zookeeper 在选举 leader 时会停止服务，只有成功选举 leader 成功后才能提供服务，选举时间较长；内部使用 paxos 选举投票机制，只有获取半数以上的投票才能成为 leader，否则重新投票，所以部署的时候最好集群节点不小于 3 的奇数个（但是谁能保证跪掉后节点也是基数个呢）；Zookeeper 健康检查一般是使用 tcp 长链接，在内部网络抖动时或者对应节点阻塞时候都会变成不可用，这里还是比较危险的。</p>
<h4 id="Consul"><a href="#Consul" class="headerlink" title="Consul"></a>Consul</h4><p>&emsp;&emsp;和 Zookeeper 一样数据 CP。</p>
<p>&emsp;&emsp;Consul 注册时候只有过半的节点都写入成功才认为注册成功；leader 挂掉时，重新选举期间整个 Consul 不可用,保证了强一致性但牺牲了可用性。<br>&emsp;&emsp;有很多 blog 说 Consul 属于 ap，官方已经确认他为 CP 机制 原文地址：<a target="_blank" rel="noopener" href="https://www.consul.io/docs/intro/vs/serf。">https://www.consul.io/docs/intro/vs/serf。</a></p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a target="_blank" rel="noopener" href="https://github.com/doocs/advanced-java/blob/master/docs/distributed-system/distributed-system-cap.md">1. distributed-system-cap</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/01/02/%E5%88%86%E5%B8%83%E5%BC%8F-%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86-100-%E6%9D%A1%E5%88%86%E7%BC%95%E6%9E%90%E5%88%86%E5%B8%83%E5%BC%8F%EF%BC%9A%E5%88%B0%E5%BA%95%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%80%E8%87%B4%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Peng Chen">
      <meta itemprop="description" content="彭晨的简单记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pengchen's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/02/%E5%88%86%E5%B8%83%E5%BC%8F-%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86-100-%E6%9D%A1%E5%88%86%E7%BC%95%E6%9E%90%E5%88%86%E5%B8%83%E5%BC%8F%EF%BC%9A%E5%88%B0%E5%BA%95%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%80%E8%87%B4%E6%80%A7/" class="post-title-link" itemprop="url">分布式系统原理——100. 条分缕析分布式：到底什么是一致性？</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-02 17:38:21" itemprop="dateCreated datePublished" datetime="2021-01-02T17:38:21+08:00">2021-01-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-03 17:57:32" itemprop="dateModified" datetime="2021-01-03T17:57:32+08:00">2021-01-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&emsp;&emsp;这篇文章取自<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzA4NTg1MjM0Mg==&amp;mid=2657261779&amp;idx=1&amp;sn=9fb74c24f8863837d584a96536ba8189&amp;scene=21#wechat_redirect">这篇博客</a>，作为整理和收录，方便后续查阅。本篇文章非常推荐，与作者接下来的几篇文章都很不错，对于网上的分布式理论见解很深，且引的参考文章都很不错，可以参考看看，提升分布式系统理解很有帮助。</p>
<p>&emsp;&emsp;凡是做服务器开发的技术同学，估计都对分布式系统以及相关的理论感兴趣。而对于分布式理论，大家讨论的最多的恐怕就是「分布式一致性」问题了。然而，不管是学术界还是业界的发展历史上，对于「一致性」这个概念的理解，始终充满了混乱。</p>
<p>&emsp;&emsp;如果你问一个技术同学，到底什么是分布式一致性，估计会得到五花八门的答案。这其中比较常见的说法可能是这样的：一致性就是多个服务器节点中的数据保持一致（至少百度百科上差不多就是这么说的）。而如果再讨论得深入一点，可能就会谈到所谓的分布式一致性协议，比如Paxos之类的；还有CAP定理，也跟「一致性」有关。</p>
<p>&emsp;&emsp;但是，「一致性」这个词是非常有迷惑性的。如果用英文来表达的话，跟「一致性」有关的至少有两个词：<em>consistency</em>和<em>consensus</em>。它们经常都被翻译成「一致性」，这进一步加剧了这个概念被滥用的程度。为了接下来讨论方便，我们先简单地澄清一下：</p>
<ul>
<li>网上通常提到的诸如Paxos之类的分布式一致性协议，其实是<em>consensus</em>这个词。它如果被翻译成「共识」，可能会更好一些。为了表达清晰，本文后面在讨论<em>consensus</em>问题的时候，尽量使用「共识」这个词。</li>
<li>ACID或CAP里C，用的都是<em>consistency</em>这个词，但真实含义迥然不同。</li>
<li>此外，还经常会听到人们关于「强一致性」的说法，而且这种说法通常都会牵涉到CAP定理或者「分布式事务」的概念。「强一致性」与CAP定理确实关系密切，但与「分布式事务」的关系却不知从何而来。</li>
</ul>
<p>&emsp;&emsp;下面，我们就对这些概念进行详细的解析。</p>
<h3 id="ACID中的一致性"><a href="#ACID中的一致性" class="headerlink" title="ACID中的一致性"></a>ACID中的一致性</h3><p>&emsp;&emsp;ACID是数据库事务的四个特性，分别是原子性 (Atomicity)、一致性 (Consistency)、隔离性 (Isolation)和持久性 (Durability)。</p>
<p>&emsp;&emsp;我们现在关注的是其中的C，即一致性<em>Consistency</em>。它是什么意思呢？通俗地说，它指的是任何一个数据库事务的执行，都应该让整个数据库保持在「一致」的状态。那怎样的状态才算「一致」呢？举个例子，假设在银行账户之间进行转账。显然，「转账」这个操作应该确保在转账前后账户总额保持不变，这是任何一个转账操作必须要遵守的规定。现在假设要从账户A向账户B转账100元，于是我们启动了一个数据库事务。在这个事务中，可以先从账号A中减去100元，再往账户B中增加100元。这样的一个事务操作，满足了“转账前后账户总额保持不变”的规定，因此我们说：这个事务操作保持了数据库的「一致性」；同时，在这个事务执行前后，数据库都处于一种「一致」的状态。</p>
<p>&emsp;&emsp;从上一段的描述中，我们容易看出：</p>
<ul>
<li>ACID中的「一致性」，是对于整个数据库的「一致」状态的维持。抽象来看，对数据库每进行一次事务操作，它的状态就发生一次变化。这相当于把数据库看成了状态机，只要数据库的起始状态是「一致」的，并且每次事务操作都能保持「一致性」，那么数据库就能始终保持在「一致」的状态上 (Consistency Preservation)。</li>
<li>所谓状态是不是「一致」，其实是由业务层规定的。比如前面这个转账的例子，“转账前后账户总额保持不变”，这个规定只对于「转账」这个特定的业务场景有效。如果换一个业务场景，「一致」的概念就不是这样规定了。所以说，ACID中的「一致性」，其实是体现了业务逻辑上的合理性，并不是由数据库本身的技术特性所决定的。</li>
</ul>
<p>&emsp;&emsp;我们再来看一下，为了让事务总是能保持ACID的一致性，我们需要在实现上考虑哪些因素呢？</p>
<p>&emsp;&emsp;至少两个方面需要考虑：一个是出错情况 (failure/error)；一个是并发 (concurrency) 行为。</p>
<p>&emsp;&emsp;首先，对于任何系统来说，错误都是在所难免的。而错误又可以细分为两类。</p>
<p>&emsp;&emsp;第一类，事务本身的实现逻辑可能存在错误。比如，从账户A向账户B转账100元，在这个事务中，如果我们只从账号A中减去了100元，但忘记了往账户B中增加100元，那么这个事务就是错误的。显然，避免第一类错误，是保持一致性的前提，这需要应用层进行恰当的编码来保证。</p>
<p>&emsp;&emsp;第二类，则是意想不到的各种软硬件错误。比如，还是从账户A向账户B转账100元，事务本身的实现逻辑没有问题，它先执行了从账号A中减去了100元，但在执行往账户B中增加100元之前，却发生了意想不到的错误，比如进程突然crash了，或是磁盘满了，或是网络突然不通了，或是其它任何可能的硬件错误。这时候，事务只执行了前一半，势必会破坏数据库整体状态的一致性。那怎么办呢？这其实就需要ACID中的A（原子性）来保障了。简言之，原子性保障了事务的执行要么全部成功，要么全部失败，而不允许出现“只执行了一半”这种“部分成功”的情况。</p>
<p>&emsp;&emsp;其次，并发行为也可能会影响事务的一致性。在数据库系统中，并发行为体现在可能存在多个事务同时操作同一份数据的情况。还是拿前面转账的例子来说，假设有两个事务：事务1从账户A向账户B转账100元，事务2从账户A向账户C转账50元。如果两个事务先后顺序执行，自然没有问题。但如果两个事务同时执行了，那么可能会出现下面的执行序列（假设账号A的初始余额为x元）：</p>
<ol>
<li>&lt;事务1&gt;：读取账户A的余额，读到了x元；</li>
<li>&lt;事务2&gt;：读取账户A的余额，也读到了x元；</li>
<li>&lt;事务1&gt;：向账户A中写入(x-100)元；</li>
<li>&lt;事务2&gt;：向账户A中写入(x-50)元；</li>
<li>……</li>
</ol>
<p>&emsp;&emsp;上面的执行过程，账户A中最后被写入的值是(x-50)元，显然是不对的（事务的一致性会被破坏）。如果两个转账的事务能正确执行完，那么账户A的余额应该是(x-150)元才对。</p>
<p>&emsp;&emsp;这个并发的问题怎么处理呢？这就需要ACID中的I（隔离性）来保障了。什么是隔离性呢？它对于并发执行的多个事务进行合理的排序，保障了不同事务的执行互不干扰。换言之，隔离性这种特性，能够让并发执行的多个事务就好像是按照「先后顺序」执行的一样。</p>
<p>&emsp;&emsp;经过上面的分析，现在关于ACID中的一致性，我们可以得到一些结论了：</p>
<ul>
<li>ACID中的一致性，是个很偏应用层的概念。这跟ACID中的原子性、隔离性和持久性有很大的不同。原子性、隔离性和持久性，都是数据库本身所提供的技术特性；而一致性，则是由特定的业务场景规定的。怪不得《Designing Data-Intensive Applications》[1]一书的作者在书中写道：”<em>The letter C doesn’t really belong in ACID</em>“。</li>
<li>要真正做到ACID中的一致性，它是要依赖数据库的原子性和隔离性的（应对错误和并发）。但是，就算数据库提供了所有你所需要的技术特性，也不一定能保证ACID的一致性。这还取决于你在应用层对于事务本身的实现逻辑是否正确无误。</li>
<li>最后，ACID中的一致性，甚至跟分布式都没什么直接关系。它跟分布式的唯一关联在于，在分布式环境下，它所依赖的数据库原子性和隔离性更难实现。</li>
</ul>
<p>&emsp;&emsp;总之，ACID中的一致性，是一个非常特殊的概念。除了数据库事务处理，它很难扩展到其它场景，也跟分布式理论中的其它「一致性」概念没有什么关系。</p>
<h3 id="分布式事务与共识算法的关系"><a href="#分布式事务与共识算法的关系" class="headerlink" title="分布式事务与共识算法的关系"></a>分布式事务与共识算法的关系</h3><p>&emsp;&emsp;先说共识问题 (consensus problem)。这是分布式系统中的一个十分基础而核心的问题，它表示如何在分布式系统中的多个节点之间就某事达成共识。</p>
<p>&emsp;&emsp;网上通常提到的「分布式一致性协议」，或者「分布式一致性算法」，一般来说就是解决这里的共识问题的算法。用词的不同，是由于中英文翻译造成的。这些算法或协议，经常包含Paxos之类，但也可能包括两阶段提交协议(2PC)或三阶段提交协议(3PC)。</p>
<p>&emsp;&emsp;人们既然经常将Paxos、2PC、3PC这些算法放在一起讨论，那么它们之间势必存在着某种相似性的。但这种相似性是怎么来的呢？我们仔细分析一下。Paxos，是解决共识问题的通用算法。它允许每个节点提出自己的提议(称为proposal），而Paxos算法能够不借助于任何中心化节点，保证各个节点之间对于提议最终达成一致。这里的proposal，是一个抽象的概念，它可以包含任何你想达成共识的数值。2PC和3PC，则是为了解决分布式事务提交问题的。</p>
<p>&emsp;&emsp;这样从表面看起来，Paxos和2PC、3PC，这两类算法似乎没有多少相似性。2PC和3PC是跟分布式事务强相关的，而Paxos跟分布式事务没有什么特别的关系。为了分析更深层次的本质，我们探究一下2PC和3PC产生的背景。</p>
<p>&emsp;&emsp;回到事务的概念。事务本来和分布式没什么直接关系的，就算在一个单节点的数据库上，要实现出事务的ACID特性，也不是那么容易的。只是，如同在前一章节的结尾我们提到的，在分布式环境下，事务的ACID特性更难实现。在前一章中我们主要关注ACID中的一致性，现在我们关注一下ACID中的原子性 (Atomicity)。</p>
<p>&emsp;&emsp;ACID中的原子性，要求事务的执行要么全部成功，要么全部失败，而不允许出现“部分成功”的情况。在分布式事务中，这要求参与事务的所有节点，要么全部执行Commit操作，要么全部执行Abort操作。换句话说，参与事务的所有节点，需要在“执行Commit还是Abort”这一点上达成一致（其实就是共识）。这个问题在学术界被称为<strong>原子提交问题</strong>（Atomic Commitment Problem）[2]，而能够解决原子提交问题的算法，则被称为<strong>原子提交协议</strong>（Atomic Commitment Protocal，简称<strong><em>ACP</em></strong>）[3]。2PC和3PC，属于原子提交协议两种不同的具体实现。</p>
<p>&emsp;&emsp;分析到这里，我们似乎发现了<strong>原子提交问题</strong>与<strong>共识问题</strong>的关联性：</p>
<ul>
<li>共识问题，解决的是如何在分布式系统中的多个节点之间就某个提议达成共识。</li>
<li>原子提交问题，解决的是参与分布式事务的所有节点在“执行Commit还是Abort”这一点上达成共识。</li>
<li>所以，原子提交问题是共识问题的一个特例。</li>
</ul>
<p>&emsp;&emsp;这个酷似「三段论」式的论述，看起来“合情合理”。实际上，学术界在很长一段时间内都认为，分布式事务的原子提交问题是拜占庭将军问题（Byzantine Generals Problem）的一个退化形式[4]。什么是拜占庭将军问题呢？简单来说，它也是分布式系统的一种<strong>共识问题</strong>，而且是容错性要求最高的一种共识问题。我们在这里不展开讨论拜占庭将军问题了，如果你对细节感兴趣，欢迎阅读我之前的另一篇文章“<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzA4NTg1MjM0Mg==&amp;mid=2657261626&amp;idx=1&amp;sn=6b32cc7a7a62bee303a8d1c4952d9031&amp;scene=21#wechat_redirect">漫谈分布式系统、拜占庭将军问题与区块链</a>”。总之，学术界以前的这种观点，跟我们刚刚分析得到的结论（原子提交问题是共识问题的一个特例）差不多。</p>
<p>&emsp;&emsp;但是，分布式系统的诡异之处就要体现在这里，一些细节的不同，可能导致非常大的差异。如果你仔细看前文的描述，会发现这样一个细节：当我们描述共识问题的时候，我们说的是在<strong>多个节点</strong>之间达成共识；而当我们描述原子提交问题的时候，我们说的是在<strong>所有节点</strong>之间达成共识。这个细微的差别，让这两类问题，几乎变成了完全不同的问题（谁也替代不了谁）。</p>
<p>&emsp;&emsp;从两类问题各自的应用场景来看，这个差异是合理的，也是容易理解的。以解决共识问题的Paxos协议为例，它只要求网络中的大部分节点达成共识就可以了，这样Paxos才能提供一定的容错性，只要网络中发生故障的节点不超过一半仍然能够正常工作（不会被阻塞）。然而，解决原子提交问题的2PC或3PC则不同。即使只有一个节点发生故障了，其它节点也不能擅自决策进行Commit操作。因为这样的话，这个事务就只是「部分地执行成功了」，违反了ACID原子性的要求。所以，原子提交协议必须保证在参与分布式事务的<strong>所有节点</strong>（包括故障的节点）上对于“执行Commit还是Abort”达成共识。</p>
<p>&emsp;&emsp;故障的节点可能什么都做不了，如何参与达成共识呢？这里的意思是，等故障节点恢复之后，它的决策（Commit或是Abort）必须与其它所有节点保持一致。那么，这是不是意味着，只要有节点发生故障，原子提交协议就一定会阻塞呢？这里有点让人奇怪，答案是「不一定」。根源就在于Abort和Commit并不是对等的决策。假设有一个节点宕机了，其它节点大可以选择Abort决策（注意不能选择Commit），从而让整个事务Abort掉（没有被阻塞住，等待宕机的节点恢复）。等宕机的那个节点恢复了，它会发现相应的事务已经执行Abort了，那么它也按照Abort处理就好了。在这个过程中，参与分布式事务的<strong>所有节点</strong>（包括宕机的这个节点）对于“执行Commit还是Abort”也是达成了共识的（这个共识是Abort）。正是这些细微却至关重要的细节，让2PC和3PC这种看似简单的协议实现起来没有那么容易。</p>
<p>&emsp;&emsp;论文[5]进一步澄清了这一问题，原子提交问题被抽象成一个新的一致性问题，称为uniform consensus问题，它是与通常的共识问题（consensus problem）不同的问题，而且是更难的问题。uniform consensus，要求所有节点（包括故障节点）都要达成共识；而consensus问题只关注没有发生故障的节点达成共识。</p>
<p>&emsp;&emsp;至此，我们总结一下本章节的结论：</p>
<ul>
<li>共识问题（consensus problem），解决的是如何在分布式系统中的多个节点之间就某个提议达成共识。它只关注没有发生故障的节点达成共识就可以了。</li>
<li>在分布式事务中，ACID中的原子性，引出了原子提交问题，它解决的是参与分布式事务的所有节点在“执行Commit还是Abort”这一点上达成共识。原子提交问题属于uniform consensus问题，要求所有节点（包括故障节点）都要达成共识，是比consensus问题更难的一类问题。</li>
<li>Paxos和解决拜占庭将军问题的算法，解决的是consensus问题；2PC/3PC，解决的是一个特定的uniform consensus问题。</li>
</ul>
<h3 id="CAP与线性一致性"><a href="#CAP与线性一致性" class="headerlink" title="CAP与线性一致性"></a>CAP与线性一致性</h3><p>&emsp;&emsp;CAP的三个字母分别代表了分布式系统的三个特性：一致性（Consistency）、可用性（Availability）和分区容错性（Partition-tolerance）。而CAP定理指出：任何一个分布式系统只能同时满足三个特性中的两个。但是，这一描述曾经引发了非常多的误解。</p>
<p>&emsp;&emsp;为了进一步展开讨论，我们先关注CAP中的C，也就是一致性。它是什么意思呢？在证明CAP定理的原始论文中[6]，C指的是<em>linearizable consistency</em>，也就是「线性一致性」。更精简的英文表达则是<em>linearizability</em>。</p>
<p>&emsp;&emsp;这听起来可能稍微有点奇怪，但事实就是这样。<strong>线性一致性</strong>（<em>linearizability</em>）是CAP中的C的原始定义。而很多人在谈到CAP时，则会把这个C看成是<strong>强一致性</strong>（<em>strong consistency</em>）。这其实也没错，因为线性一致性的另一个名字，就是强一致性[1]。只不过，相比「线性一致性」来说，「强一致性」并不是一个好名字。因为，从这个名字你看不出来它真实的含义（到底「强」在哪？）。在下面的讨论中，我们统一使用线性一致性(<em>linearizability</em>)这个词汇。</p>
<p>&emsp;&emsp;那线性一致性是什么意思呢？它精确的形式化定义[7]非常抽象，且难以理解。大体上是说，在一个并发执行的环境中，不同的操作之间可能是有严格的先后关系的（一个操作执行结束之后另一个操作才开始执行），也可能是并发执行的（一个操作还没执行结束，另一个操作就开始执行了）；如果能够把所有操作排列成一个「合法」的全局线性顺序，那么这些操作就是满足线性一致性的。当然，在这个重新排列的过程中，原来就存在的严格的先后关系，必须得以保持。</p>
<p>&emsp;&emsp;但是，怎么才算合法呢？我们具体到一个存储系统中通过例子来说明。假如我们先往某个数据对象中写入了一个值（假设是1），然后在写入操作结束之后，我们再把这个数据对象读出来（在写入和读取操作之间没有其它的写入操作了）。如果我们发现读取到的值是1，那么就是合法的；而如果读出来的值不是1，那么就是非法的。再假设，我们又执行了一次读取操作，发现读出来的值仍然是1，那么就是合法的；否则就是非法的。也就是说，如果一个读操作已经读到了某个值，那么下一个对于同一个数据对象的读操作就必须读取到同样的值（除非在两次读操作之间还存在别的写入操作）。</p>
<p>&emsp;&emsp;这些例子都比较容易理解，因为站在观察者的角度它们是符合逻辑的。因此，对于一个分布式存储系统来说，线性一致性的含义可以用一个具体的描述来取代：对于任何一个数据对象来说，<strong>系统表现得就像它只有一个副本一样</strong>[1]。“表现得像只有一个副本”，也就相当于满足了前面的「合法」条件。显然，如果系统对于每个数据对象真的只存一个副本，那么肯定是满足线性一致性的。但是单一副本不具有容错性，所以分布式存储系统一般都会对数据进行复制（replication），也就是保存多个副本。这时，在一个分布式多副本的存储系统中，要提供线性一致性的保证，就需要付出额外的成本了。</p>
<p>&emsp;&emsp;网上对于CAP的一致性的通俗解释，通常有两种：</p>
<ol>
<li>一致性是指：在分布式系统完成某写操作后的任何读操作，都应该获取到该写操作写入的那个最新的值。显然，如果系统“表现得像只有一个副本”一样，这个描述是成立的。不过这只是描述了线性一致性的一个特例而已，有以偏概全的嫌疑。</li>
<li>一致性是指：保持所有节点在同一个时刻具有相同的、逻辑一致的数据。显然这种解释并不是从观察者的角度来描述的，而是试图从系统内部的行为（内部实现）来描述的。「所有节点」，可能指的是「所有副本」；至于“在同一个时刻具有相同的、逻辑一致的数据”这个说法，则似乎离线性一致性的本来含义偏离太远了。从逻辑上说，“表现得像只有一个副本”，并不一定需要系统“在同一个时刻具有相同的、逻辑一致的数据”。线性一致性可能有很多种实现方式，而这种解释规定了一种具体的系统实现，同样有以偏概全的嫌疑。</li>
</ol>
<p>&emsp;&emsp;我们前面提到，线性一致性，也被称为强一致性。之所以这么说，大概是因为线性一致性要求多个副本上的数据必须保持如此之「强」的一致性，以至于“让系统表现得就像只有一个副本”。</p>
<p>&emsp;&emsp;另外，网上的资料提到强一致性的时候，还有可能会关联到分布式事务上面，比如2PC/3PC这些原子提交协议。但把它们关联到一起的说法，其深层次含义到底是什么，只能靠猜测。分布式事务处理的并不是同一个数据对象的多个副本的问题，而指的是将针对多个数据对象的各种操作组合起来，提供ACID的特性。将分布式事务看成是强一致性的保证，猜测可能实际上指的就是ACID的原子性。总之，「强一致性」这个词很容易产生误解，所以建议谨慎使用。</p>
<p>&emsp;&emsp;在历史上，CAP定理具有巨大的知名度，但它实际的影响力却没有想象的那么大。随着分布式理论的发展，我们逐渐认识到，CAP并不是一个「大一统」的理论，远不能涵盖分布式系统设计中方方面面的问题。相反，CAP引发了很多误解和理解上的混乱（细节不讨论了）。因此，可以预见到，未来CAP定理的影响将会进一步被削弱。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;本文我们辨析了分布式系统中的诸多被称为「一致性」的概念。但这个话题还没有完，我将在下一篇文章中跟大家继续讨论顺序一致性、线性一致性、最终一致性等概念。</p>
<h3 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h3><ul>
<li>[1] Martin Kleppmann,《Designing Data-Intensive Applications》, 2017.</li>
<li>[2] Vassos Hadzilacos, “On The Relationship Between The Atomic Commitment And Consensus Problems”, 1990.</li>
<li>[3] Philip A. Bernstein, Vassos Hadzilacos, Nathan Goodman, 《Concurrency Control And Recovery in Database Systems》, 1987.</li>
<li>[4] Jim Gray, “A Comparison Of The Byzantine Agreement Problem And The Transaction Commit Problem”, 1988.</li>
<li>[5] Bernadette Charron-Bost, André Schiper, “Uniform Consensus Is Harder Than Consensus”, 2001.</li>
<li>[6] Seth Gilbert, Nancy Lynch, “Brewer’s Conjecture and the Feasibility of Consistent, Available, Partition-Tolerant Web”, 2002.</li>
<li>[7] MAURICE P. HERLIHY, JEANNETTE M. WING, “Linearizability: A Correctness Condition for Concurrent Objects”, 1990.</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/01/03/%E5%88%86%E5%B8%83%E5%BC%8F-%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86-101-%E6%9D%A1%E5%88%86%E7%BC%95%E6%9E%90%E5%88%86%E5%B8%83%E5%BC%8F%EF%BC%9A%E6%B5%85%E6%9E%90%E5%BC%BA%E5%BC%B1%E4%B8%80%E8%87%B4%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Peng Chen">
      <meta itemprop="description" content="彭晨的简单记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pengchen's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/03/%E5%88%86%E5%B8%83%E5%BC%8F-%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86-101-%E6%9D%A1%E5%88%86%E7%BC%95%E6%9E%90%E5%88%86%E5%B8%83%E5%BC%8F%EF%BC%9A%E6%B5%85%E6%9E%90%E5%BC%BA%E5%BC%B1%E4%B8%80%E8%87%B4%E6%80%A7/" class="post-title-link" itemprop="url">分布式系统原理——101. 条分缕析分布式：浅析强弱一致性</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-01-03 17:55:33 / 修改时间：18:10:43" itemprop="dateCreated datePublished" datetime="2021-01-03T17:55:33+08:00">2021-01-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&emsp;&emsp;这篇文章取自<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzA4NTg1MjM0Mg==&amp;mid=2657261790&amp;idx=1&amp;sn=08449ee5b39d93b25442c1e583e3ba99&amp;scene=21#wechat_redirect">这篇博客</a>，作为整理和收录，方便后续查阅。本篇文章非常推荐，与作者接下来的几篇文章都很不错，对于网上的分布式理论见解很深，且引的参考文章都很不错，可以参考看看，提升分布式系统理解很有帮助。</p>
<p>&emsp;&emsp;当前这篇文章至少比计划拖后了两个月。在上一篇文章《<a target="_blank" rel="noopener" href="https://yangtzeshore.github.io/2021/01/02/%E5%88%86%E5%B8%83%E5%BC%8F-%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86-100-%E6%9D%A1%E5%88%86%E7%BC%95%E6%9E%90%E5%88%86%E5%B8%83%E5%BC%8F%EF%BC%9A%E5%88%B0%E5%BA%95%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%80%E8%87%B4%E6%80%A7/">条分缕析分布式：到底什么是一致性？</a>》中，我们仔细辨析了「一致性」相关的几个容易混淆的概念。而在本文中，我们会沿着逐步深入的思路，跟大家继续讨论顺序一致性、线性一致性、最终一致性等几个概念。</p>
<p>为了避免产生歧义，我们先明确一下这几个概念的英文表达：</p>
<ul>
<li>顺序一致性的英文是：<em>sequential consistency</em>。</li>
<li>线性一致性的英文是：<em>linearizability</em>。实际上，它就是CAP定理中的C，我们在<a target="_blank" rel="noopener" href="https://yangtzeshore.github.io/2021/01/02/%E5%88%86%E5%B8%83%E5%BC%8F-%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86-100-%E6%9D%A1%E5%88%86%E7%BC%95%E6%9E%90%E5%88%86%E5%B8%83%E5%BC%8F%EF%BC%9A%E5%88%B0%E5%BA%95%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%80%E8%87%B4%E6%80%A7/">上一篇文章</a>中已经提到过。</li>
<li>最终一致性的英文是：<em>eventual consistency</em>。</li>
</ul>
<p>&emsp;&emsp;在进行详细的技术性讨论之前，我们先把本文要讨论的几个重点问题和结论列出如下：</p>
<ul>
<li>线性一致性和顺序一致性，属于分布式系统的一致性模型 (<em>consistency model</em>)。这代表了分布式系统的一个非常非常重要的方面。</li>
<li>通常人们把线性一致性称为「强一致性」，把最终一致性称为「弱一致性」，但线性一致性和最终一致性其实存在本质的区别。严格来说，它们并不是一个范畴的概念。</li>
<li>一致性模型之间的「强弱」比较，是一个相对的概念。比如，线性一致性是比顺序一致性更强的一致性模型。当然，除了线性一致性和顺序一致性，也存在其它一些一致性模型（其中很多都比顺序一致性要弱）。</li>
<li>满足线性一致性的系统，也必定满足顺序一致性，但反过来不一定。这是由一致性模型之间的强弱关系决定的。</li>
</ul>
<p>&emsp;&emsp;下面，我们就开始详细的解析。</p>
<h3 id="一致性模型的来历"><a href="#一致性模型的来历" class="headerlink" title="一致性模型的来历"></a>一致性模型的来历</h3><p>&emsp;&emsp;我们之所以使用分布式系统，无非是因为分布式系统能带来一些「好处」，比如容错性、可扩展性等等。为了获得这些「好处」，分布式系统实现上常用的方法是复制 (<em>replication</em>) 和分片 (<em>sharding</em>)。而我们将要讨论的一致性模型 (<em>consistency model</em>)，主要是与复制有关。因此这里我们先关注一下复制的机制。</p>
<p>&emsp;&emsp;复制指的是将同一份数据保存在多个网络节点上。而保存同一份数据拷贝的节点，被称为副本 (replica)。复制带来的具体「好处」主要是体现在两个方面：</p>
<ul>
<li>容错 (<em>fault tolerance</em>)。即使某些网络节点发生故障，由于原本保存着在故障节点上的数据在正常节点上还有备份，所以整个系统仍然可能是可用的。这也是我们期待分布式系统能够提供的「高可用」特性。</li>
<li>提升吞吐量。将一份数据复制多份并保存在多个副本节点上，还顺便带来一个好处：对于同一个数据对象的访问请求（至少是读请求）可以由多个副本节点分担，从而使得整个系统可以随着请求量的增加不断扩展。</li>
</ul>
<p>&emsp;&emsp;一方面，复制带来了诸多好处；另一方面，它也带来了很多挑战，其中最重要的一个就是数据的一致性问题。由于同一份数据保存在了多个副本节点上，它们之间就存在数据不一致的风险。我们当然希望同一份数据的不同副本总是保持一致。换句话说，我们希望在其中一个副本上所做的修改，在其它副本上也能随时观察到（即读取到）。</p>
<p>&emsp;&emsp;当然我们心里都清楚，让所有副本在任何时刻都保持一致，是不可能的。因为副本之间的数据同步即使速度再快，也是需要时间的。不过幸运的是，我们其实并不关心所有时刻的数据一致性情况。只要系统能够保证，每当我们去「观察」的时候（即读取数据副本的时候），系统表现出来的行为是一致的，就可以了。换句话说，即使在两次「观察」之间，系统内部出现了短暂的数据不一致的情况，只要系统保证外部用户无论如何都发现不了，我们也是可以满意的。</p>
<p>&emsp;&emsp;这意味着，我们应该从系统用户（使用系统的开发者）的角度，来对数据一致性的要求进行定义。</p>
<p>实际上，早期的分布式系统设计者们对系统设计的要求，也是按照类似的思路进行的。在理想情况下，系统应该维持类似SSI (<em>single-system image</em>)[1]或<em>distribution transparency</em>[2]的特性。这两个概念要表达的核心意思是，系统内部有关分布式实现的复杂性应该对系统的外部用户透明；也就是说，对于系统的外部用户来说，系统应该表现得就好像只有一个单一的副本一样。如果系统能够提供这种「单一系统视图」或「透明性」，那么系统的使用者就能以比较简单的方式来使用系统；否则就可能带来很大的负担。</p>
<p>&emsp;&emsp;系统“表现得就好像只有一个单一的副本”，这是一个相当「笼统」的说法。在此我们讨论3个具体的例子：</p>
<ol>
<li>我们先向一个副本节点写入<em>x</em>=42，然后读取数据对象<em>x</em>的值。显然，不管我们从哪个副本节点上进行读取，我们都希望读到最新写入的值（也就是42）。只有这样才合理。</li>
<li>两个系统用户分别在两个副本节点上同时执行写操作。其中，用户A在第1个副本上执行<em>x</em>=42；用户B在第2个副本上执行<em>x</em>=43。然后用户C读取<em>x</em>的值。虽然两个写操作是「同时」进行的，但为了让系统“表现得像只有一个副本”，我们还是需要对它们进行一个先后排序。又因为它们是「同时」执行的，所以谁先谁后都有可能是合理的。如果我们认为<em>x</em>=42在<em>x</em>=43之前先执行，那么读取到的<em>x</em>的值就应该是43；反过来，如果我们认为<em>x</em>=43在x=42之前先执行，那么读取到的<em>x</em>的值就应该是42。</li>
<li>用户A先在第1个副本上执行<em>x</em>=42，然后用户B再在第2个副本上执行<em>x</em>=43，最后用户C在第3个副本上读取<em>x</em>的值。仍然为了让系统“表现得像只有一个副本”，直觉上看，用户C读取到的<em>x</em>的值似乎应该是43。但是，也不一定非要如此。因为两个写操作是分别由用户A和用户B发起的，他们并不知道彼此谁先谁后（虽然从时间上看用户A的写操作确实在先）。所以，我们也可以选择认为用户B执行<em>x</em>=43在用户A执行<em>x</em>=42之前。这样的话，用户C读取到的<em>x</em>的值就应该是42。当然，根据本文后面的讨论，这种排序就不满足线性一致性了，但却满足顺序一致性。</li>
</ol>
<p>&emsp;&emsp;从这些例子不难看出，一个系统在数据一致性上的具体表现如何，取决于系统对关键事件（读写操作）的排序和执行采取什么样的规则和限制。比如在上面第3个例子中，出现了两种对于读写操作的排序。前一种排序是：</p>
<ol>
<li>用户A执行<em>x</em>=42。</li>
<li>用户B执行<em>x</em>=43。</li>
<li>用户C读取到<em>x</em>的值是43。</li>
</ol>
<p>而第3个例子中的后一种排序是：</p>
<ol>
<li>用户B执行<em>x</em>=43。</li>
<li>用户A执行<em>x</em>=42。</li>
<li>用户C读取到<em>x</em>的值是42。</li>
</ol>
<p>&emsp;&emsp;虽然这两种排序结果不同，但它们都做到了让系统“表现得像只有一个副本”。它们的不同在于，前一种排序遵循了不同用户的操作的时间先后顺序，而后一种排序没有。实际上，如果我们要求系统满足线性一致性，就只能得到前一种排序结果；而如果只要求系统满足顺序一致性，就有可能得到后一种排序结果（等看完本文后面的讨论，你就能自己得到这些结论）。</p>
<p>&emsp;&emsp;可以这么说，一个分布式系统对于读写操作的某种排序和执行规则，就定义了一种一致性模型 (<em>consistency model</em>)。当一个系统选定了某种特定的一致性模型（比如线性一致性或顺序一致性），那么你就只能看到这种一致性模型所允许的那些操作序列。还是拿前面第3个例子来说明：如果你选定了线性一致性模型，那么系统就不会向你呈现后一种排序，你只能看到前一种排序。</p>
<p>&emsp;&emsp;另外，在前面的三个例子中，不管系统最终给出了哪种排序结果，所有系统的用户其实都对那种操作序列达成了一致的看法。还有一些一致性模型，并不要求所有用户对操作排序的结果达成唯一的一种看法。这样的一致性模型稍显复杂，我们会放在下一篇文章中再讨论（比如因果一致性）。</p>
<p>&emsp;&emsp;接下来，为了更清晰地认识一致性模型，我们来深入到线性一致性和顺序一致性的一些细节中去。</p>
<h3 id="线性一致性和顺序一致性"><a href="#线性一致性和顺序一致性" class="headerlink" title="线性一致性和顺序一致性"></a>线性一致性和顺序一致性</h3><p>&emsp;&emsp;在讨论之前，我们先把组成分布式系统的一些关键概念定义清楚：</p>
<ul>
<li>整个系统可以看成由多个<strong>进程</strong>和一个共享的<strong>数据存储</strong>组成。对于数据存储的读写操作由进程发起。这里的进程，相当于本文前面提到的系统用户或系统使用者。</li>
<li>同一个进程发起的读写操作是先后顺序执行的。注意，这里的「进程」概念跟我们平常编程时用到的进程有所不同，进程里面不再分多个线程了。</li>
<li>数据存储可能有多个副本，但我们在讨论一致性模型的时候，把它看成一个整体来看待，不区分读写操作提交到了具体哪个副本上。</li>
<li>每个操作的执行，从开始调用到执行结束，都需要花一定的时间。因此，一个进程发起的操作还没有执行完的时候，另一个进程的操作可能就已经开始了。</li>
</ul>
<p>&emsp;&emsp;可见，系统的多个进程是并发执行的。下面我们通过一个例子来说明这种并发执行的情况，进而解释顺序一致性的概念。</p>
<p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/%E5%88%86%E5%B8%83%E5%BC%8F/1.webp" alt="图片"></p>
<p>&emsp;&emsp;上面是一个类似「时空图」的图像，表达了3个进程（<em>P</em>1、<em>P</em>2和<em>P</em>3）对于数据存储的读写执行过程。在这个图中，横向从左到右表示时间递增，黑色的线段表示每个操作的执行起止。线段上面的符号表示具体的读写操作：</p>
<ul>
<li><em>A</em> —&gt; <em>w**i</em>(<em>x</em>)，表示一个写操作：第<em>i</em>个进程向数据对象<em>x</em>写入了值<em>A</em>。</li>
<li><em>r**i</em>(<em>x</em>) —&gt; <em>A</em>，表示一个读操作：第<em>i</em>个进程从数据对象<em>x</em>中读到了值<em>A</em>。</li>
</ul>
<p>&emsp;&emsp;现在我们要考察的问题是：上图的这样一个执行过程，是否满足顺序一致性？要回答这个问题，我们首先得知道顺序一致性的定义是什么。</p>
<p>&emsp;&emsp;<strong>顺序一致性</strong>定义[3,4]：如果一个并发执行过程所包含的所有读写操作能够重排成一个全局线性有序的序列，并且这个序列满足以下两个条件，那么这个并发执行过程就是满足顺序一致性的：</p>
<ul>
<li><strong>条件I</strong>：重排后的序列中每一个读操作返回的值，必须等于前面对同一个数据对象的最近一次写操作所写入的值。</li>
<li><strong>条件II</strong>：原来每个进程中各个操作的执行先后顺序，在这个重排后的序列中必须保持一致。</li>
</ul>
<p>&emsp;&emsp;以上图的执行过程为例，我们重排所有的6个读写操作，可以得到如下的有序序列：</p>
<ol>
<li><em>A</em> —&gt; <em>w**1</em>(<em>x</em>)</li>
<li><em>r**3</em>(<em>x</em>) —&gt; <em>A</em></li>
<li><em>C</em> —&gt; <em>w**2</em>(<em>x</em>)</li>
<li><em>r**3</em>(<em>x</em>) —&gt; <em>C</em></li>
<li><em>B</em> —&gt; <em>w**1</em>(<em>x</em>)</li>
<li><em>r**3</em>(<em>x</em>) —&gt; <em>B</em></li>
</ol>
<p>&emsp;&emsp;很容易看出，这个序列是满足前面顺序一致性定义中的两个条件的：</p>
<ul>
<li>条件I：在这个重排后的序列中，每个读操作都返回了前面最近一次写入的值，比如第2个操作读到的值<em>A</em>，是前面第1个操作写入的；第4个操作读到的值<em>C</em>，是前面第3个操作写入的。</li>
<li>条件II：原来进程<em>P</em>1中的两个写操作，<em>A</em> —&gt; <em>w**1</em>(<em>x</em>)和<em>B</em> —&gt;<em>w**1</em>(<em>x</em>)，在这个重排后的序列中仍然保持了先后顺序。与此类似，原来进程<em>P</em>3中的3个读操作，在这个重排后的序列中也保持了原来的先后顺序。</li>
</ul>
<p>&emsp;&emsp;所以现在我们可以回答前面的问题了：上图中的执行过程，是满足顺序一致性的。</p>
<p>&emsp;&emsp;你可能会问，顺序一致性为什么会这样定义呢？这个定义的初衷是什么？</p>
<p>&emsp;&emsp;我们可以试着这样理解：首先，重排成一个全局线性有序的序列，相当于系统对外表现出了一种「假象」，原本多进程并发执行的操作，好像是顺序执行的一样。本文前面提到过，理想情况下，分布式系统应该“表现得像只有一个副本”一样。顺序一致性正是遵循了这种「系统假象」，系统对外表现就好像在操作一个单一的副本，执行顺序也必然是可以看做顺序执行的。而条件I规定了系统的表现是合理的（即合乎逻辑的）；条件II则保证了以任何进程的视角来看，它所发起的操作执行顺序都是符合它原本的预期的。总之，一个满足顺序一致性的系统，对外表现就好像总是在操作一个副本一样。</p>
<p>&emsp;&emsp;我们再通过一个例子来看一看这个问题的反面——不满足顺序一致性的执行过程是怎样的。</p>
<p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/%E5%88%86%E5%B8%83%E5%BC%8F/2.webp" alt="图片"></p>
<p>&emsp;&emsp;这个图中的执行过程，与前面第一个图的执行过程非常相似，只是进程<em>P</em>3的几个操作的执行顺序稍有变化。</p>
<p>&emsp;&emsp;我们根据前面顺序一致性的定义再来试着对这个执行过程中的所有操作进行重排：首先根据条件II和进程<em>P</em>1的执行顺序，我们知道，<em>A</em> —&gt; <em>w**1</em>(<em>x</em>)一定要排在<em>B</em> —&gt; <em>w**1</em>(<em>x</em>)前面；再根据条件I，进程<em>P</em>1的<em>B</em> —&gt; <em>w**1</em>(<em>x</em>)一定要排在进程<em>P</em>3的<em>r**3</em>(<em>x</em>) —&gt; <em>B</em>前面。最后，再结合条件II和进程<em>P</em>3的执行顺序，我们能够得出结论，进程<em>P</em>1和进程<em>P</em>3的所有操作，在最终重排后的完整序列中，必然保持以下的顺序：</p>
<ol>
<li><em>A</em> —&gt; <em>w**1</em>(<em>x</em>)</li>
<li><em>B</em> —&gt; <em>w**1</em>(<em>x</em>)</li>
<li><em>r**3</em>(<em>x</em>) —&gt; <em>B</em></li>
<li><em>r**3</em>(<em>x</em>) —&gt; <em>C</em></li>
<li><em>r**3</em>(<em>x</em>) —&gt; <em>A</em></li>
</ol>
<p>&emsp;&emsp;我们会发现，上面的序列有两个地方不满足条件I：</p>
<ul>
<li>第4个操作读到了值<em>C</em>，而前面最近一次写操作（第2个操作）所写入的值是<em>B</em>。</li>
<li>第5个操作读到了值<em>A</em>，而前面最近一次写操作（也是第2个操作）所写入的值是<em>B</em>。</li>
</ul>
<p>&emsp;&emsp;我们还剩一个进程<em>P</em>2的写操作，即<em>C</em> —&gt; <em>w**2</em>(<em>x</em>)，没有放到最后这个序列中。也许我们可以试着将它放置到第3和第4个操作之间，这样就能把前面第一个不满足条件I的地方修复掉。但无论如何，也无法得到一个完全符合条件I和条件II的完整序列了。因此，前面第二个图中的执行过程，是不满足顺序一致性的。进一步说，如果一个系统的执行呈现出了这样的一种执行过程（如前面第二个图所示），那我们可以肯定地说，这个系统是没有遵守顺序一致性的。</p>
<p>&emsp;&emsp;我们再来考察一下线性一致性的概念。线性一致性的定义[5]，与顺序一致性非常相似，也是试图把所有读写操作重排成一个全局线性有序的序列，但除了满足前面的条件I和条件II之外，还要同时满足一个条件：</p>
<ul>
<li><strong>条件III</strong>：不同进程的操作，如果在时间上不重叠，那么它们的执行先后顺序，在这个重排后的序列中必须保持一致。</li>
</ul>
<p>&emsp;&emsp;根据最新定义的条件III，我们来重新评判一下前面第一个图所展现出来的执行过程是不是满足它。为了阅读和讨论方便，我们把第一个图重新展示在下面：</p>
<p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/%E5%88%86%E5%B8%83%E5%BC%8F/3.webp" alt="图片"></p>
<p>&emsp;&emsp;针对条件III，我们分析一下各个操作之间的先后顺序：</p>
<ul>
<li>进程<em>P</em>1的<em>B</em> —&gt; <em>w**1</em>(<em>x</em>)和进程<em>P</em>2的<em>C</em> —&gt; <em>w**2</em>(<em>x</em>)，在执行时间上是重叠的，所以它们的排序不受条件III的约束。即，在重排后的序列中，这两个操作谁先谁后都可以。同样，进程<em>P</em>1的<em>B</em> —&gt; <em>w**1</em>(<em>x</em>)和进程<em>P</em>3的<em>r**3</em>(<em>x</em>) —&gt; <em>A</em>，也是如此。</li>
<li>进程<em>P</em>1的<em>A</em> —&gt; <em>w**1</em>(<em>x</em>)和进程<em>P</em>2的<em>C</em> —&gt; <em>w**2</em>(<em>x</em>)，在执行时间上是不重叠的，即前一个操作都执行完了，后一个操作才开始执行。那么，这两个操作就必须满足条件III了：在重排后的序列中，<em>A</em> —&gt; <em>w**1</em>(<em>x</em>)必须排在<em>C</em> —&gt; <em>w**2</em>(<em>x</em>)前面。</li>
<li>与上面同样的道理，在重排后的序列中，进程<em>P</em>2的<em>C</em> —&gt;<em>w**2</em>(<em>x</em>)必须排在进程<em>P</em>3的<em>r**3</em>(<em>x</em>) —&gt; <em>A</em>之前。</li>
</ul>
<p>&emsp;&emsp;容易看出，在遵守这样的先后关系约束的前提下，不管怎么重排，都无法得到一个满足条件I的完整序列了。所以说，前面第一个图所示的满足顺序一致性的执行过程，是不满足线性一致性的。</p>
<p>&emsp;&emsp;下面我们举一个满足线性一致性的例子：</p>
<p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/%E5%88%86%E5%B8%83%E5%BC%8F/4.webp" alt="图片"></p>
<p>&emsp;&emsp;上图的执行过程，所有操作重排后，可以得到如下的有序序列：</p>
<ol>
<li><em>A</em> —&gt; <em>w**1</em>(<em>x</em>)</li>
<li><em>r**3</em>(<em>x</em>) —&gt; <em>A</em></li>
<li><em>C</em> —&gt; <em>w**2</em>(<em>x</em>)</li>
<li><em>r**3</em>(<em>x</em>) —&gt; <em>C</em></li>
<li><em>B</em> —&gt; <em>w**1</em>(<em>x</em>)</li>
<li><em>r**3</em>(<em>x</em>) —&gt; <em>B</em></li>
</ol>
<p>&emsp;&emsp;不难看出，这个序列是满足所有的条件I、条件II和条件III这三个条件的。因此，这个执行过程满足线性一致性。</p>
<p>&emsp;&emsp;细心的你可能已经发现了，最后这个线性一致性的例子，得到的重排后的序列，与开始第一个顺序一致性的例子重排后的序列，完全相同。当然，这两个例子中原始的多进程并发执行过程，是不同的。这是符合预期的（没有什么可奇怪的）。</p>
<p>&emsp;&emsp;现在我们可以仔细分析一下条件II和条件III，它们囊括了任意两个操作之间所有可能的先后关系：</p>
<ul>
<li>进程内的任意两个操作之间，总是先后顺序执行的（执行时间上不可能重叠）；而根据条件II，它们的先后顺序在最后重排后的序列中也会保持。</li>
<li>不同进程的不同操作之间，在执行时间上可能重叠（并发执行），也可能不重叠。根据条件III，不重叠的两个操作，它们在时间上的先后顺序，在最后重排后的序列中会得以保持。而对于执行时间上重叠的两个操作，它们在最后重排后的序列中的先后顺序没有规定。</li>
</ul>
<p>&emsp;&emsp;最后，我们比较一下顺序一致性和线性一致性：</p>
<ul>
<li>它们都试图让系统“表现得像只有一个副本”一样。</li>
<li>它们都保证了程序执行顺序不会被打乱。体现在条件II对于进程内各个操作的排序保持上。</li>
<li>线性一致性考虑了时间先后顺序，而顺序一致性没有。</li>
<li>满足线性一致性的执行过程，肯定都满足顺序一致性；反之不一定。</li>
</ul>
<p>&emsp;&emsp;注意一下上面第3点两者在时间先后顺序上的不同。这意味着：</p>
<ul>
<li>线性一致性隐含了时效性保证（recency guarantee）。它保证我们总是能读到数据最新的值。</li>
<li>在顺序一致性中，我们有可能读到旧版本的数据。比如，在本文第一个顺序一致性的例子中，在进程<em>P</em>2将数据对象<em>x</em>的值写成了<em>C</em>之后，进程<em>P</em>3仍然读到了旧的值（<em>A</em>）。</li>
</ul>
<h3 id="最终一致性和它的特殊性"><a href="#最终一致性和它的特殊性" class="headerlink" title="最终一致性和它的特殊性"></a>最终一致性和它的特殊性</h3><p>&emsp;&emsp;我们在<a target="_blank" rel="noopener" href="https://yangtzeshore.github.io/2021/01/02/%E5%88%86%E5%B8%83%E5%BC%8F-%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86-100-%E6%9D%A1%E5%88%86%E7%BC%95%E6%9E%90%E5%88%86%E5%B8%83%E5%BC%8F%EF%BC%9A%E5%88%B0%E5%BA%95%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%80%E8%87%B4%E6%80%A7/">上一篇文章</a>中提到过，CAP定理[6]中的C，指的就是线性一致性 (<em>linearizability</em>)。它也经常被称为「强一致性」。</p>
<p>&emsp;&emsp;根据CAP定理，当存在网络分区的时候，我们必须在可用性 (<em>availability</em>) 和强一致性之间进行取舍。</p>
<p>&emsp;&emsp;另外，即使在没有网络分区存在的情况下，我们也必须在延迟 (<em>latency</em>) 和强一致性之间进行取舍[7]。这是因为，系统维持强一致性是有成本的。想要维持越强的一致性，就需要在副本节点之间做更多的通信和协调工作，因此会降低操作的总延迟，进而降低整个系统的性能。</p>
<p>&emsp;&emsp;从20世纪90年代中期开始，互联网开始蓬勃发展，系统的规模也变得越来越大。人们设计大型分布式系统的指导思想，也逐步开始更倾向于系统的高可用性和高性能。取舍的结果就是，降低系统提供的一致性保障。这其中非常重要的一条思路就是最终一致性[2]。</p>
<p>&emsp;&emsp;最终一致性的设计思路，不再试图提供单一系统视图 (SSI)，即不再试图让系统“表现得像只有一个副本”一样。它允许读到旧版本的数据。最终一致性的原始出处是论文[2]，作者在论文中给出的最终一致性的定义如下：</p>
<blockquote>
<p>Eventual consistency. This is a specific form of weak consistency; the storage system guarantees that if no new updates are made to the object, eventually all accesses will return the last updated value.(译文：最终一致性是弱一致性的一种特殊形式；存储系统保证，如果对象没有新的修改操作，那么所有的访问最终都会返回最新写入的值。)</p>
</blockquote>
<p>&emsp;&emsp;我们发现，虽然最终一致性和本文前面讨论的线性一致性或顺序一致性在命名上非常相似，但它的定义却与后两者存在非常大的差别。深层的原因在于，它们其实属于不同类别的系统属性 (<em>property</em>)。线性一致性和顺序一致性属于<em>safety property</em>（安全性）；而最终一致性属于<em>liveness property</em>（活性）[8]。</p>
<p>&emsp;&emsp;一个并发程序或者一个分布式系统，它们的执行所展现出来的系统属性，可以分为两大类：</p>
<ul>
<li><strong><em>safety\</em></strong>：它表示「坏事」永远不会发生。比如，一个系统如果遵守线性一致性或顺序一致性，那么就永远不会出现违反三个（对于顺序一致性来说是两个）条件的执行过程。而一旦系统出现问题，<em>safety</em>被违反了，我们也能明确指出是在哪个时间点上出现意外的。</li>
<li><strong><em>liveness\</em></strong>：它表示「好事」最终会发生。这种属性听起来会比较神奇：在任何一个时间点，你都无法判定<em>liveness</em>被违反了。因为，即使你期望的「好事」还没有发生，也不代表它未来不会发生。就像最终一致性一样，即使当前系统处于不一致的状态，也不代表未来系统就不会达到一致的状态。而只要系统存在“在未来某个时刻达到一致状态”的可能性，最终一致性就没有被违反。另外，可用性 (<em>availability</em>) 也属于<em>liveness</em>属性。</li>
</ul>
<p>&emsp;&emsp;由此可见，我们在前一小节之所以能够将线性一致性和顺序一致性放在一起讨论和比较，是因为它们都属于<em>safety</em>属性。而最终一致性属于<em>liveness</em>属性，跟这两者存在本质的区别。实际上，最终一致性有点名不副实，它更好的名字可能是收敛性 (<em>convergence</em>)，表示所有副本最终都会收敛到相同的值[9]。</p>
<p>&emsp;&emsp;通常来说，只有当<em>safety</em>和<em>liveness</em>这两种属性被同时考虑时，一个系统才能提供有意义的系统保证[1]。而当系统设计者遵循最终一致性的设计思路时，相当于放弃了所有的<em>safety</em>属性。这意味着，对于系统使用者来说，你必须针对数据不一致的可能性做好补偿措施 (<em>compensation</em>)。这也是最终一致性系统难用的地方。但不管怎么说，最终一致性仍然被认为是系统提供数据一致性的最低要求[1]。</p>
<h3 id="一致性的强弱关系"><a href="#一致性的强弱关系" class="headerlink" title="一致性的强弱关系"></a>一致性的强弱关系</h3><p>&emsp;&emsp;在本文开头，我们提到过，通常人们把线性一致性称为「强一致性」，把最终一致性称为「弱一致性」。但对于指代特定的一种一致性模型来说，「强一致性」和「弱一致性」都不是一个好名字。因为强和弱，是个相对的概念。</p>
<p>&emsp;&emsp;根据本文前面的讨论，从线性一致性，到顺序一致性，再到最终一致性，一致性的强度依次减弱。但是，一致性模型的强弱关系，其实是有更严格的定义的：</p>
<ul>
<li>当且仅当一个一致性模型所能接受的执行过程，都能被另一个一致性模型所接受时（前者的集合是后者集合的子集），我们就说前者是比后者「更强」(stronger) 的一致性模型。</li>
</ul>
<p>&emsp;&emsp;按照这个更严格的强弱关系定义，线性一致性是比顺序一致性更强的一致性模型。这是因为，线性一致性比顺序一致性多了一个条件III，所以凡是满足线性一致性的执行过程，肯定也满足顺序一致性。</p>
<p>&emsp;&emsp;我们仔细分析一下也能知道，一致性模型的强弱关系定义，是基于<em>safety</em>属性定义的。所以，将线性一致性或顺序一致性与最终一致性比较强弱，这并不是一个严格的做法。实际上，就像我们前一小节所讨论的，最终一致性在<em>safety</em>方面提供的保证为零，它是属于<em>liveness</em>的概念。一个系统可以在提供最终一致性的同时，也提供另外一种更强一点的带有<em>safety</em>属性的一致性（比如因果一致性）。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;就如同我在之前另外一篇文章《<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzA4NTg1MjM0Mg==&amp;mid=2657261626&amp;idx=1&amp;sn=6b32cc7a7a62bee303a8d1c4952d9031&amp;scene=21#wechat_redirect">漫谈分布式系统、拜占庭将军问题与区块链</a>》中所指出的，<strong>理解问题本身比知道问题的答案要重要的多</strong>。本文中，我们辨析了线性一致性、顺序一致性、最终一致性这些概念，以及他们的关系和区别。由此我们了解到了分布式系统的一些核心问题，但我们并未讨论怎么解决这些问题。比如，采用什么算法才能提供线性一致性；面对最终一致性的系统，应该怎样编程，包括怎样处理边界情况，等等。相对于理解问题本身而言，这些反而都是细节。</p>
<p>&emsp;&emsp;在这个系列的下一篇文章中，我们将依然遵循这样的思路，具体解析因果一致性，以及分布式系统更深层的事件排序问题。</p>
<h3 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h3><ul>
<li>[1] Peter Bailis, Ali Ghodsi, “Eventual Consistency Today: Limitations, Extensions, and Beyond”, 2013.</li>
<li>[2] Werner Vogels, “Eventually Consistent”, 2008.</li>
<li>[3] Leslie Lamport, “How to Make a Multiprocessor Computer That Correctly Executes Multiprocess Progranm”, 1979.</li>
<li>[4] Mustaque Ahamad, Gil Neiger, James E. Burns, et al, “Causal Memory: Definitions, Implementation and Programming”, 1994.</li>
<li>[5] Maurice P. Herlihy, Jeannette M. Wing, “Linearizability: A Correctness Condition for Concurrent Objects”, 1990.</li>
<li>[6] Seth Gilbert, Nancy Lynch, “Brewer’s Conjecture and the Feasibility of Consistent, Available, Partition-Tolerant Web”, 2002.</li>
<li>[7] Peter Bailis, Ali Ghodsi, et al, “Bolt-on Causal Consistency”, 2013.</li>
<li>[8] Bowen Alpern, Fred B. Schneider, “Defining Liveness”, 1985.</li>
<li>[9] Martin Kleppmann,《Designing Data-Intensive Applications》, 2017.</li>
<li>[10] Prince Mahajan, Lorenzo Alvisi, Mike Dahlin, “Consistency, Availability, and Convergence”, 2011.</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/01/03/%E5%88%86%E5%B8%83%E5%BC%8F-%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86-102-%E6%9D%A1%E5%88%86%E7%BC%95%E6%9E%90%E5%88%86%E5%B8%83%E5%BC%8F%EF%BC%9A%E5%9B%A0%E6%9E%9C%E4%B8%80%E8%87%B4%E6%80%A7%E5%92%8C%E7%9B%B8%E5%AF%B9%E8%AE%BA%E6%97%B6%E7%A9%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Peng Chen">
      <meta itemprop="description" content="彭晨的简单记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pengchen's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/03/%E5%88%86%E5%B8%83%E5%BC%8F-%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86-102-%E6%9D%A1%E5%88%86%E7%BC%95%E6%9E%90%E5%88%86%E5%B8%83%E5%BC%8F%EF%BC%9A%E5%9B%A0%E6%9E%9C%E4%B8%80%E8%87%B4%E6%80%A7%E5%92%8C%E7%9B%B8%E5%AF%B9%E8%AE%BA%E6%97%B6%E7%A9%BA/" class="post-title-link" itemprop="url">分布式系统原理——102. 条分缕析分布式：因果一致性和相对论时空</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-01-03 20:22:01 / 修改时间：20:36:15" itemprop="dateCreated datePublished" datetime="2021-01-03T20:22:01+08:00">2021-01-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&emsp;&emsp;这篇文章取自<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/wkXsRufVsbKqTwjzTgNqYQ">这篇博客</a>，作为整理和收录，方便后续查阅。本篇文章非常推荐，与作者接下来的几篇文章都很不错，对于网上的分布式理论见解很深，且引的参考文章都很不错，可以参考看看，提升分布式系统理解很有帮助。</p>
<p>&emsp;&emsp;在上一篇文章《<a target="_blank" rel="noopener" href="https://yangtzeshore.github.io/2021/01/03/%E5%88%86%E5%B8%83%E5%BC%8F-%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86-101-%E6%9D%A1%E5%88%86%E7%BC%95%E6%9E%90%E5%88%86%E5%B8%83%E5%BC%8F%EF%BC%9A%E6%B5%85%E6%9E%90%E5%BC%BA%E5%BC%B1%E4%B8%80%E8%87%B4%E6%80%A7/">条分缕析分布式：浅析强弱一致性</a>》中，我们重点讨论了顺序一致性、线性一致性和最终一致性这几个概念。本文我们将继续深入，详细探讨另一种一致性模型——因果一致性，并在这个过程中逐步逼近分布式系统最深层的事件排序的本质。沿着这个方向，如果我们走得稍微再远一点，就会触达我们所生活的这个宇宙的时空本质，以及因果律的本质（这才是真正有意思的地方，希望你能一口气读到最后）。</p>
<p>&emsp;&emsp;回到现实，《Designing Data-Intensive Applications》[1]一书的作者在他的书中提到，基于因果一致性构建分布式数据库系统，是未来一个非常有前景的研究方向。而且，估计很少有人注意到，我们经常使用的ZooKeeper，其实就在session维度上提供了因果一致性的保证[2]。理解「因果一致性」的概念，有助于我们对于分布式系统的认识更进一层。</p>
<h3 id="为什么要考虑因果一致性？"><a href="#为什么要考虑因果一致性？" class="headerlink" title="为什么要考虑因果一致性？"></a>为什么要考虑因果一致性？</h3><p>&emsp;&emsp;结合<a target="_blank" rel="noopener" href="https://yangtzeshore.github.io/2021/01/03/%E5%88%86%E5%B8%83%E5%BC%8F-%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86-101-%E6%9D%A1%E5%88%86%E7%BC%95%E6%9E%90%E5%88%86%E5%B8%83%E5%BC%8F%EF%BC%9A%E6%B5%85%E6%9E%90%E5%BC%BA%E5%BC%B1%E4%B8%80%E8%87%B4%E6%80%A7/">上一篇文章</a>的讨论，我们再把一致性模型的来历简单梳理一下。</p>
<p>&emsp;&emsp;早期的分布式系统设计者，为了让使用系统的开发者能够以比较简单的方式来使用系统，希望分布式系统能提供单一系统视图 (SSI，<em>single-system image</em>)[3]，即系统“表现得就好像只有一个单一的副本”。线性一致性和顺序一致性就是沿着这个思路设计的。满足线性一致性或顺序一致性的系统，对读写操作的排序呈现全局唯一的一种次序。</p>
<p>&emsp;&emsp;然而，系统为了维持这种全局排序的一致性是有成本的，必然需要在副本节点之间做很多通信和协调工作。这降低了系统的可用性（<em>availability</em>）和性能。于是，在一致性、可用性、系统性能之间进行权衡的结果，就是降低系统提供的一致性保障，转向了最终一致性[4]。</p>
<p>&emsp;&emsp;不过最终一致性提供的一致性保障是如此之弱，它放弃了所有的<em>safety</em>属性（具体讨论见<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzA4NTg1MjM0Mg==&amp;mid=2657261790&amp;idx=1&amp;sn=08449ee5b39d93b25442c1e583e3ba99&amp;scene=21#wechat_redirect">上一篇文章</a>）。这给系统的使用带来了额外的困难。面向最终一致性系统进行编程，需要随时关注数据不一致的情况。加州大学伯克利分校在2013年发表了一篇非常不错的文章[3]，对于如何在最终一致性系统上构建应用，进行了非常深入的研究。文章指出了两种思路：</p>
<ul>
<li>针对可能出现的数据不一致情况实施补偿措施 (<em>compensation</em>)。这需要在分布式系统之上的应用层面进行额外的处理，是非常容易出错且费时费力的。</li>
<li>基于CALM定理和CRDTs，完全消除补偿操作。但这样做其实限制了应用编程能够使用的操作类型，也就限制了系统能力。</li>
</ul>
<p>&emsp;&emsp;以上两种思路都涉及到了大量细节，我们不打算在这里深入讨论，有兴趣的读者可以仔细去阅读论文[3]。</p>
<p>&emsp;&emsp;总之，为了提高系统可用性和系统性能，人们放弃了强一致性，采取了几乎最弱的一类一致性模型（最终一致性），但也同时牺牲了系统的能力或系统使用的便利性。那么，到底有没有必要一定采取这么「弱」的一致性模型呢？有没有可能在最终一致性的基础上增加一点<em>safety</em>属性，提供稍强一点的一致性，但同时也不至于对系统可用性和性能产生明显的损害呢？</p>
<p>&emsp;&emsp;基于最新的研究，这是有可能的。这个问题的答案就是本文接下来要讨论的因果一致性 (<em>causal consistency</em>)。</p>
<p>&emsp;&emsp;德克萨斯大学奥斯汀分校在2011年的一项研究表明[5]：</p>
<ul>
<li>不存在比因果一致性更强的一致性模型，能够在网络分区的情况下仍然可用。</li>
<li>在一个永远保持可用且单程收敛 (<em>always-available, one-way convergent</em>) 的系统里，因果一致性是可以被实现出来的。</li>
</ul>
<h3 id="因果一致性的直观解释"><a href="#因果一致性的直观解释" class="headerlink" title="因果一致性的直观解释"></a>因果一致性的直观解释</h3><p>&emsp;&emsp;因果律是这个世界最基础的规律，物理法则决定了我们总是先看到事物的「因」，后看到事物的「果」。对于一个分布式系统来说，在数字世界中保持这种因果关系，当然也是一个最基本的要求。</p>
<p>&emsp;&emsp;为了能比较通俗地理解因果一致性，我们这里引用一个假想的实例（来自论文[6]）。假设Billy是一个小男孩，Sally是他的妈妈。下面的故事发生在一个类似Facebook的社交网站上：</p>
<ol>
<li>有一天，Billy失踪了。Sally找不到他的儿子，很着急，于是在社交网站上发布了一条状态：“我儿子Billy丢了！”</li>
<li>过了一会，Sally突然接到了儿子的电话。Billy告诉妈妈，他跑到朋友家玩去了。Sally长出一口气，又重新修改了刚才发布的状态：“谢天谢地，虚惊一场！Billy原来是跑出去玩了。”</li>
<li>Sally的一个朋友，叫James，看到了她发的最新的状态，在社交网站上回复了她：“太好了，总算松了一口气！”</li>
</ol>
<p>&emsp;&emsp;假如这家社交网站的数据库系统没能保证因果一致性，那么我们就可能看到比较奇怪的事件次序。假设Sally的另外一个朋友，叫Henry，也在浏览这个社交网站。可能由于系统延迟，数据还未收敛到一致的状态，Henry可能会看到Sally发的第一条状态和James的回复，但却看不到Sally发的第二条状态。于是，在Henry看来：</p>
<ol>
<li>Sally说：“我儿子Billy丢了！”</li>
<li>James回复：“太好了，总算松了一口气！”</li>
</ol>
<p>&emsp;&emsp;Henry可能会错误地认为，James满心希望Sally的儿子丢了（James肯定是恨透了Sally）！</p>
<p>&emsp;&emsp;之所以发生这样的问题，就是因为因果倒置了。考虑两个事件：事件A，Sally发布第二条状态（称自己的儿子找到了）；事件B，James回复Sally表示安慰。显然，事件B是由事件A引发的，也就是说，事件A是事件B的「因」，事件B是事件A的「果」。但在Henry看来，却只看到了事件B，没有看到事件A，这违反了因果规律。（当然，这个例子隐藏了很多具体实现细节，你可能会产生一些疑问，但不妨碍我们讨论事件的因果关系）</p>
<p>&emsp;&emsp;这里需要注意，如果分布式系统是满足线性一致性或者顺序一致性的，那么是不会发生这样的问题的。因为线性一致性和顺序一致性是能够保持因果关系的（下一章节我们还会继续讨论这个问题）。而只是满足最终一致性的系统，是没法总是保持因果关系的。但是，如果一个系统满足因果一致性，那么我们可以放心地认为，事件的因果关系是能够得到保证的。</p>
<p>&emsp;&emsp;现在，让我们来尝试对因果一致性进行定义。我们先采取一种不那么严格，但比较直观的说法（下个章节再进行精确定义）。因果一致性遵守下面三条规则：</p>
<ol>
<li>单进程写操作有序。</li>
<li>“writes follow reads”规则。</li>
<li>因果关系可传递。</li>
</ol>
<p>&emsp;&emsp;我们来分别解释一下：</p>
<ol>
<li>单进程写操作有序，指的是一个进程的多个写操作（可能是针对不同的数据对象的），在所有进程看来都是遵循同样的执行顺序。对应到前面的例子中，Sally的所有朋友都会看到，Sally是先发了一条状态“我儿子Billy丢了！”，然后又发了第二条状态“谢天谢地，虚惊一场！Billy原来是跑出去玩了。”这条规则保证了没有人是先看到第二条状态然后才看到第一条状态的。对于这个次序的保证也是因果性的一种体现。</li>
<li>“writes follow reads”指的是，假设第一个进程先读取到了数据对象<em>x=5</em>，后写入了另一个数据对象<em>y=10</em>，然后第二个进程读到了<em>y=10</em>，那么接下来如果这个进程读取数据对象<em>x</em>的值，那么不能读到一个比<em>x=5</em>更旧的值。这条规则在不同进程的不同数据对象之间建立了因果关联。对应到前面的例子中，James看到了Sally发的最新状态：“谢天谢地，虚惊一场！Billy原来是跑出去玩了。”（相当于读到了<em>x=5</em>），然后回复说：“太好了，总算松了一口气！”（相当于写入了<em>y=10</em>），再然后Henry看到了James的回复内容（相当于第二个进程读到了<em>y=10</em>），这时候站在Henry的视角上看Sally发布的状态，他不能比James看到的数据版本更旧。前面的例子中出现的问题就在于，Henry比James看到了更旧的一个数据版本：“我儿子Billy丢了！”，致使因果关系混乱了。</li>
<li>因果关系是具有传递性的。如果操作A和操作B在因果关系上满足先后次序，而且操作B和操作C在因果关系上也满足先后次序，那么A和C在因果关系上必然是满足先后次序的。</li>
</ol>
<h3 id="因果一致性的精确定义"><a href="#因果一致性的精确定义" class="headerlink" title="因果一致性的精确定义"></a>因果一致性的精确定义</h3><p>&emsp;&emsp;在前一章节我们讨论了因果一致性的直观解释，但我们还需要一个精确的定义。这样对于一个具体的包含读写操作的并发执行过程来说，我们才能知道如何判定它是否满足因果一致性。</p>
<p>&emsp;&emsp;我们采用<a target="_blank" rel="noopener" href="https://yangtzeshore.github.io/2021/01/03/%E5%88%86%E5%B8%83%E5%BC%8F-%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86-101-%E6%9D%A1%E5%88%86%E7%BC%95%E6%9E%90%E5%88%86%E5%B8%83%E5%BC%8F%EF%BC%9A%E6%B5%85%E6%9E%90%E5%BC%BA%E5%BC%B1%E4%B8%80%E8%87%B4%E6%80%A7/">上一篇文章</a>的表示方法，还是先通过一个例子来看一个并发执行过程，如下图：</p>
<p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/%E5%88%86%E5%B8%83%E5%BC%8F/5.webp" alt="图片"></p>
<p>&emsp;&emsp;图中线段上面的符号表示具体的读写操作：</p>
<ul>
<li><em>A</em> —&gt; <em>w**i</em>(<em>x</em>)，表示一个写操作：第<em>i</em>个进程向数据对象<em>x</em>写入了值<em>A</em>。</li>
<li><em>r**i</em>(<em>x</em>) —&gt; <em>A</em>，表示一个读操作：第<em>i</em>个进程从数据对象<em>x</em>中读到了值<em>A</em>。</li>
</ul>
<p>&emsp;&emsp;这个图表达了3个进程（<em>P</em>1、<em>P</em>2和<em>P</em>3）对于数据存储的读写执行过程。它是否满足因果一致性呢？</p>
<p>&emsp;&emsp;跟线性一致性和顺序一致性的定义一样，因果一致性也是表达了系统对于读写操作的某种排序规则。为此我们首先需要定义清楚一个关键概念——<strong>因果顺序</strong> (causality order)，它表明了两个不同操作之间的排序是怎样规定的。</p>
<p>&emsp;&emsp;<strong>因果顺序</strong>的定义：如果两个操作<em>o</em>1和<em>o</em>2满足下面三个条件之一，那么它们就是满足因果顺序的，记为<em>o</em>1→<em>o</em>2：</p>
<ul>
<li>(1) <em>o</em>1和<em>o</em>2属于同一个进程，且<em>o</em>1在<em>o</em>2前面执行。</li>
<li>(2) <em>o</em>1是个写操作，<em>o</em>2是个读操作，且<em>o</em>2读到的值是由<em>o</em>1写入的。</li>
<li>(3) 存在一个操作<em>o</em>‘满足<em>o</em>1→<em>o</em>‘→<em>o</em>2。</li>
</ul>
<p>&emsp;&emsp;结合上图的例子，我们解释一下这三个条件：</p>
<ul>
<li>(1) 同一个进程内部先后执行的两个操作，不管他们是读操作还是写操作，都是满足因果顺序的。比如上图中<em>P</em>1进程的 <em>A</em> —&gt;<em>w**1</em>(<em>x</em>) 和 <em>B</em> —&gt; <em>w**1</em>(<em>x</em>) 两个操作就是满足因果顺序的；<em>P</em>2进程的<em>r**2</em>(<em>x</em>) —&gt; <em>B</em> 和 <em>C</em> —&gt; <em>w**2</em>(<em>y</em>) 也是满足因果顺序的。这一条件表明，因果顺序遵从了进程的执行顺序。</li>
<li>(2) 如果一个读操作读到的值是由另一个写操作写入的（肯定是针对同一个数据对象），那么不管它们是不是属于同一个进程，这个写操作和读操作就是满足因果关系的。比如上图中的 <em>B</em> —&gt;<em>w**1</em>(<em>x</em>) 和 <em>r**2</em>(<em>x</em>) —&gt; <em>B</em> 就是满足因果顺序的；<em>C</em> —&gt; <em>w**2</em>(<em>y</em>) 和 <em>r**3</em>(<em>y</em>) —&gt; <em>C</em> 也是满足因果顺序的。这个条件反映了读写操作之间的因果依赖关系。</li>
<li>(3) 这个条件表明因果顺序“→”满足传递关系 (<em>transitive relation</em>)。</li>
</ul>
<p>&emsp;&emsp;从因果顺序的定义中，我们还能得到两个重要的结论：</p>
<ul>
<li>因果顺序是一种<strong>偏序关系</strong>。所谓偏序关系，就是说只有一部分操作是可以按照因果顺序进行比较的，而有一些操作之间是不能比较的。比如上图中的 <em>A</em> —&gt; <em>w**1</em>(<em>x</em>) 和 <em>D</em> —&gt; <em>w**3</em>(<em>x</em>) 这两个操作之间的关系，就不符合因果顺序三个条件中的任何一个。<em>r**2</em>(<em>x</em>) —&gt; <em>B</em> 和 <em>D</em> —&gt; <em>w**3</em>(<em>x</em>) 之间也同样如此，它们之间不存在因果顺序。这具有很深刻的物理学和哲学内涵，因为现实世界的事件之间的因果关系就是偏序的（先不展开讨论）。分布式系统里对于读写操作之间的这种因果顺序的定义，正是对现实世界中这种现象的一种刻画。</li>
<li>因果顺序不能有循环依赖。假如操作<em>o</em>1→<em>o</em>2→<em>o</em>‘→…→<em>o</em>1，由传递关系就应该有：<em>o</em>1→<em>o</em>1。这表示一个操作是它自己的「因」，这是荒谬的。换句话说，如果把因果顺序用一个图来表示，那么它应该是一个有向无环图 (<em>directed acyclic graph</em>)。</li>
</ul>
<p>&emsp;&emsp;现在基于<strong>因果顺序</strong>的定义，我们可以给出<strong>因果一致性</strong>的定义了。</p>
<p>&emsp;&emsp;<strong>因果一致性</strong>定义[7]：在一个并发执行过程中，站在其中任意一个进程<em>P**i</em>的视角上，考虑这个进程的所有读、写操作和所有其它进程的所有写操作（注意不包含读操作），得到一个操作序列。如果站在任意一个进程的视角上得到的这个操作序列都能够重排成一个线性有序的序列，并且该序列满足以下两个条件，那么这个并发执行过程就是满足因果一致性的：</p>
<ul>
<li><strong>条件I</strong>：重排后的序列中每一个读操作返回的值，必须等于前面对同一个数据对象的最近一次写操作所写入的值。</li>
<li><strong>条件II</strong>：重排后的序列遵从前面定义的因果顺序“→”。</li>
</ul>
<p>&emsp;&emsp;对比<a target="_blank" rel="noopener" href="https://yangtzeshore.github.io/2021/01/03/%E5%88%86%E5%B8%83%E5%BC%8F-%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86-101-%E6%9D%A1%E5%88%86%E7%BC%95%E6%9E%90%E5%88%86%E5%B8%83%E5%BC%8F%EF%BC%9A%E6%B5%85%E6%9E%90%E5%BC%BA%E5%BC%B1%E4%B8%80%E8%87%B4%E6%80%A7/">上一篇文章</a>中的顺序一致性定义，因果一致性的定义有两个不同：</p>
<ol>
<li>顺序一致性是对所有进程的所有读写操作进行统一的重排，而因果一致性是站在每个进程的视角各自进行局部重排。这表示顺序一致性要求系统的所有进程都对操作排序达成一致的看法，而因果一致性允许每个进程对操作的排序有不同的看法。</li>
<li>因果一致性与顺序一致性的<strong>条件II</strong>不同。顺序一致性的<strong>条件II</strong>只是要求遵从进程的执行顺序，而因果一致性则有更强的要求——遵从<strong>因果顺序</strong>（而进程的执行顺序只是因果顺序的一部分）。</li>
</ol>
<p>&emsp;&emsp;以前面图示的并发执行过程为例，我们先以<em>P</em>1的视角，需要考虑把<em>P</em>1的所有读写操作和<em>P</em>2、<em>P</em>3的所有写操作进行重排，可以得到如下的有序序列：</p>
<ol>
<li><em>D</em> —&gt; <em>w**3</em>(<em>x</em>)</li>
<li><em>A</em> —&gt; <em>w**1</em>(<em>x</em>)</li>
<li><em>B</em> —&gt; <em>w**1</em>(<em>x</em>)</li>
<li><em>C</em> —&gt; <em>w**2</em>(<em>y</em>)</li>
</ol>
<p>&emsp;&emsp;再以<em>P</em>2的视角，需要考虑把<em>P</em>2的所有读写操作和<em>P</em>1、<em>P</em>3的所有写操作进行重排，可以得到如下的有序序列：</p>
<ol>
<li><em>D</em> —&gt; <em>w**3</em>(<em>x</em>)</li>
<li><em>A</em> —&gt; <em>w**1</em>(<em>x</em>)</li>
<li><em>B</em> —&gt; <em>w**1</em>(<em>x</em>)</li>
<li><em>r**2</em>(<em>x</em>) —&gt; <em>B</em></li>
<li><em>C</em> —&gt; <em>w**2</em>(<em>y</em>)</li>
</ol>
<p>&emsp;&emsp;最后以<em>P</em>3的视角，需要考虑把<em>P</em>3的所有读写操作和<em>P</em>1、<em>P</em>3的所有写操作进行重排，可以得到如下的有序序列：</p>
<ol>
<li><em>D</em> —&gt; <em>w**3</em>(<em>x</em>)</li>
<li><em>A</em> —&gt; <em>w**1</em>(<em>x</em>)</li>
<li><em>B</em> —&gt; <em>w**1</em>(<em>x</em>)</li>
<li><em>C</em> —&gt; <em>w**2</em>(<em>y</em>)</li>
<li><em>r**3</em>(<em>y</em>) —&gt; <em>C</em></li>
<li><em>r**3</em>(<em>x</em>) —&gt; <em>B</em></li>
</ol>
<p>&emsp;&emsp;我们可以依次检查三个重排序列，会发现因果一致性的 <strong>条件I</strong>和<strong>条件II</strong>都是满足的（留给读者自己去检查，有疑问可以在评论区回复），所以前面图中的并发执行过程是满足因果一致性的。</p>
<p>&emsp;&emsp;你可能会觉得因果一致性的定义有些复杂，那么它的设计初衷是什么呢？我们通过分析两个问题来做初步的解读：</p>
<ul>
<li>为什么因果一致性是站在各个进程的视角对部分操作进行排序，而不是对所有进程的操作进行全局排序？这是因为，因果顺序是一种偏序关系，这就允许站在不同进程的视角去观察各自所关心的部分操作，从而得到不同的观察结果（排序序列）且同时不违反因果律。假如因果顺序不是一种偏序，而是一种全局关系，那么就可以把所有操作按照同一个次序排序起来，那就变成跟顺序一致性一样了，每个进程也可以看到完全一样的排序序列了。所以说，这里隐含着一个结论：因果一致性是比顺序一致性更弱的一类一致性模型，而顺序一致性也意味着遵从了因果一致性。另外，也只有当站在不同进程的视角有不同的观察结果时，才可能在发生网络分区的时候，同时提供可用性。想象当一个节点同系统其它部分隔开了，这个节点不需要等待与其它节点联系，仍然可以使用旧版本的数据提供服务，同时不违反因果顺序即可。而如果像顺序一致性或者线性一致性那样，维持一个统一的全局排序，则需要在各个节点之间充分交换完数据才能达成一致。</li>
<li>为什么站在一个进程的视角要考虑所有其它进程的写操作呢？因为对于<strong>因果顺序</strong>来说，所有写操作都是潜在的「因」，而当前进程的读操作则代表了它的「看法」。进程的局部看法的形成，需要考虑所有的「因」，才能保证不违反因果律。</li>
</ul>
<p>&emsp;&emsp;最后我们再来看一下，前一章节提到的因果一致性遵守的三条规则，是不是在因果一致性的定义中包含了：</p>
<ol>
<li>单进程写操作有序。因为每个进程进行局部重排的时候，都把所有进程的写操作考虑进去了，所以任何一个进程的多个写操作，在所有进程看来都是遵循同样的执行顺序。比如前面例子中<em>P</em>1的两个操作 <em>A</em> —&gt; <em>w**1</em>(<em>x</em>) 和 <em>B</em> —&gt; <em>w**1</em>(<em>x</em>)，在三次重排序列中都能保持次序。</li>
<li>“writes follow reads”规则。隐含在<strong>因果顺序</strong>的前两个条件里面。在前面例子中，进程<em>P</em>2先是读取到了<em>x=B</em>，后写入了<em>y=C</em>，然后进程<em>P</em>3先是读到了<em>y=C</em>，接下来进程<em>P</em>3读取<em>x</em>的值，不能读到一个比<em>x=B</em>更旧的值（满足）。</li>
<li>因果关系可传递。隐含在<strong>因果顺序</strong>的第三个条件里。</li>
</ol>
<p>&emsp;&emsp;作为对比，下图是一个违反了“writes follow reads”的例子（因此不满足因果一致性）：</p>
<p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/%E5%88%86%E5%B8%83%E5%BC%8F/6.webp" alt="图片"></p>
<h3 id="分布式系统事件排序"><a href="#分布式系统事件排序" class="headerlink" title="分布式系统事件排序"></a>分布式系统事件排序</h3><p>&emsp;&emsp;因果一致性的概念[7]，是受到Lamport的经典论文[8]的启发而设计出来的。Lamport在1978年发表的经典论文《Time, Clocks, and the Ordering of Events in a Distributed System》，经常被认为是分布式领域中最重要的一篇论文。这篇论文定义了分布式系统中不同事件之间的一种偏序关系，称为“happened before”关系，即是对因果关系的一种刻画。</p>
<p>&emsp;&emsp;Lamport定义了一种由不同进程组成的分布式系统模型，进程之间通过收发消息来传递信息。如下图：</p>
<p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/%E5%88%86%E5%B8%83%E5%BC%8F/7.webp" alt="图片"></p>
<p>&emsp;&emsp;在上图中，我们尝试对消息发送事件和消息接收事件进行排序（注意图中自下而上时间递增）。“happened before”关系也是用符号“→”来表示。</p>
<ul>
<li>在进程<em>Q</em>内部，<em>q</em>2表示一个消息接收事件，<em>q</em>4表示另一个消息发送事件，<em>q</em>2排在<em>q</em>4前面执行，所以<em>q</em>2→<em>q</em>4。</li>
<li><em>p</em>1和<em>q</em>2分别表示同一个消息的发送事件和接收事件，所以<em>p</em>1→<em>q</em>2；同理，<em>q</em>4→<em>r</em>3。</li>
<li>“happened before”满足传递关系。由<em>p</em>1→<em>q</em>2，<em>q</em>2→<em>q</em>4和<em>q</em>4→<em>r</em>3，可以推出<em>p</em>1→<em>r</em>3。</li>
</ul>
<p>&emsp;&emsp;以上三种情况，与我们前面讨论的因果顺序定义中的三个条件，基本一一对应。因果一致性的概念应用在分布式存储系统上，相当于将“happened before”关系应用在了读写操作之上。</p>
<p>&emsp;&emsp;可以看出，这里的“happened before”关系，也是一种偏序关系。比如<em>p</em>1和<em>q</em>1两个事件就是无法比较的，<em>q</em>4和<em>r</em>2也是无法比较的。无法比较的两个事件之间不满足“happened before”关系。</p>
<h3 id="因果一致性的难以理解之处"><a href="#因果一致性的难以理解之处" class="headerlink" title="因果一致性的难以理解之处"></a>因果一致性的难以理解之处</h3><p>&emsp;&emsp;经过以上的讨论，相信你已经对因果一致性有了初步的理解了。现在我们来看一个稍显奇怪的例子（下图的例子出自论文[7]）。</p>
<p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/%E5%88%86%E5%B8%83%E5%BC%8F/8.webp" alt="图片"></p>
<p>&emsp;&emsp;上图表达了两个进程的并发执行过程。它是满足因果一致性的，因为站在进程<em>P</em>1和<em>P</em>2的视角，都能得到一个局部合理的排序（满足因果顺序）。</p>
<p>&emsp;&emsp;站在<em>P</em>1视角，有：</p>
<ol>
<li><em>A</em> —&gt; <em>w**1</em>(<em>x</em>)</li>
<li><em>B</em> —&gt; <em>w**2</em>(<em>x</em>)</li>
<li><em>r**1</em>(<em>x</em>) —&gt; <em>B</em></li>
</ol>
<p>&emsp;&emsp;站在<em>P</em>2视角，有：</p>
<ol>
<li><em>B</em> —&gt; <em>w**2</em>(<em>x</em>)</li>
<li><em>A</em> —&gt; <em>w**1</em>(<em>x</em>)</li>
<li><em>r**2</em>(<em>x</em>) —&gt; <em>A</em></li>
</ol>
<p>&emsp;&emsp;以上这些分析完全符合因果一致性的定义。但是，仔细看这个例子，如果接下来没有任何进程对数据对象<em>x</em>进行写操作了，那么<em>P</em>1永远读到的是<em>x=B</em>，而<em>P</em>2永远读到的是<em>x=A</em>。这似乎有些不可思议。</p>
<p>&emsp;&emsp;发生这个现象的原因在于，进程<em>P</em>1和<em>P</em>2对于两个写操作的排序，「看法」不一致：</p>
<ul>
<li>在<em>P</em>1看来，<em>A</em> —&gt; <em>w**1</em>(<em>x</em>)发生在<em>B</em> —&gt; <em>w**2</em>(<em>x</em>)前面。</li>
<li>在<em>P</em>2看来，<em>B</em> —&gt; <em>w**2</em>(<em>x</em>)发生在<em>A</em> —&gt; <em>w**1</em>(<em>x</em>)前面。</li>
</ul>
<p>&emsp;&emsp;这就如同相对论难以理解一样：不同参照系的观察者对于不同事件的先后顺序，可能产生不同的看法。实际上，分别站在进程<em>P</em>1和<em>P</em>2的视角上，它们看到的都没有什么矛盾。矛盾发生在我们站在全局视角去看的时候。</p>
<p>&emsp;&emsp;假设躲在进程<em>P</em>1和<em>P</em>2背后的两个用户，通过系统外的通信方式进行了交流，那么他们就会发现这个奇怪之处：他们竟然对于同一个数据对象<em>x</em>读到的值不同！但是站在因果一致性的分布式系统内部来看的话，不应该发生这种情况，因为进程之间的沟通，都应该在系统内发生。所谓发生在系统内的进程之间的沟通，必定是通过进程对于数据对象的读写操作进行的。如果进程<em>P</em>1或<em>P</em>2对数据对象<em>x</em>进行了写操作，那么它们就有机会对数据对象<em>x</em>的值达成同样的看法；或者很不走运，永远也达不成同样的看法，但它们如果不借助系统外的手段永远也发现不了这种不同（还是不违反因果律）。</p>
<p>&emsp;&emsp;顺便提一句，如果要保证在系统外发生的因果联系也能在系统内永远被遵守，那么就要借助于Lamport在他的论文中提到的<strong><em>Strong Clock Condition</em></strong>了。</p>
<h3 id="更进一步"><a href="#更进一步" class="headerlink" title="更进一步"></a>更进一步</h3><p>&emsp;&emsp;我们前面提到，因果一致性对于分布式系统读写操作事件的排序，是对现实世界的事件之间因果关系的一种刻画。理解的难点在于，在我们所生活的这个宇宙中，事件之间的时间次序，只是一种偏序关系；对应的，事件之间的因果关系，也是一种偏序。</p>
<p>&emsp;&emsp;在牛顿的绝对时空观中，时间是以某个固定速率向前流逝的绝对量，而不管我们站在哪个参照系的视角上。由此带来的推论是，宇宙中发生的任何一个事件，都可以根据它们发生的绝对时间点进行先后排序。也就是说，在绝对时空中的事件之间的排序是一种全序关系，任何两个事件都能比较先后。发生在前面的事件就有可能影响后面的事件，从而产生因果关系。试想一下，就在你读到这里的几秒之前，三体星系上发生了某个重大事件，按照绝对时空观的观点，它也可能对现在的你产生了影响。你大概会同意，这是不可能的，因为三体星系即使以最快的速度向地球传递信息，也要在4年之后才能到达。</p>
<p>&emsp;&emsp;而在爱因斯坦的相对论中，这个问题就得到了解决。时间不再是一个绝对的量。不同参照系看到的时间流速可以快慢不同，甚至对两个事件的先后次序可以看法不同。但是，对于可能互相产生影响的事件，它们之间的先后次序，不管在什么参照系上看到的都应该是相同的，否则就违反了因果律。实际上，在相对论的时空中，结论是这样的：</p>
<ul>
<li>一个事件，和在它的「未来光锥」之内的任何其它事件，都是有偏序关系的。它们之间的先后次序，不管在什么参照系上看到的都应该是相同的。</li>
<li>一个事件，和在它的「未来光锥」之外的其它事件，是没有偏序关系的（也就不可能产生因果关系）。站在不同参照系上看这样的两个事件，它们的先后次序可能不同。</li>
</ul>
<p>&emsp;&emsp;回到我们的分布式系统。一个分布式系统自成宇宙，它是对现实世界的一种刻画。分布式系统由不同的进程组成，而不同的进程分布在不同的空间，每个进程可以看成一个单独的参照系。因果一致性，本质上就是按照我们对于相对论宇宙的认识来进行系统建模的，这也是它的合理性的根基。然而，分布式系统毕竟只是一个模拟系统，它是服务于系统外的现实世界的。而在现实世界中，我们还可以有额外的传递信息的方式，这相当于在分布式系统自成体系的这个「宇宙」之外，可能存在更快的传递信息的维度。所以说，分布式系统只依靠自己的逻辑，是无法与现实世界完全达成一致的。而要做到对现实的完美刻画，就一定需要考虑现实世界的实时时钟（可以从Lamport的<strong><em>Strong Clock Condition</em></strong>入手）。</p>
<p>&emsp;&emsp;到这里，我们已经触达到分布式系统（也包括这个宇宙时空）最深层的本质问题了。相信在这样的逻辑框架下，任何分布式系统的相关问题，都能很容易找到它在整个体系中的逻辑位置。至此，我们也完成了分布式一致性这个话题的「三部曲」了。其它两篇参见：</p>
<ul>
<li>《<a target="_blank" rel="noopener" href="https://yangtzeshore.github.io/2021/01/02/%E5%88%86%E5%B8%83%E5%BC%8F-%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86-100-%E6%9D%A1%E5%88%86%E7%BC%95%E6%9E%90%E5%88%86%E5%B8%83%E5%BC%8F%EF%BC%9A%E5%88%B0%E5%BA%95%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%80%E8%87%B4%E6%80%A7/">条分缕析分布式：到底什么是一致性？</a>》</li>
<li>《<a target="_blank" rel="noopener" href="https://yangtzeshore.github.io/2021/01/03/%E5%88%86%E5%B8%83%E5%BC%8F-%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86-101-%E6%9D%A1%E5%88%86%E7%BC%95%E6%9E%90%E5%88%86%E5%B8%83%E5%BC%8F%EF%BC%9A%E6%B5%85%E6%9E%90%E5%BC%BA%E5%BC%B1%E4%B8%80%E8%87%B4%E6%80%A7/">条分缕析分布式：浅析强弱一致性</a>》</li>
</ul>
<p>&emsp;&emsp;当然，分布式相关的话题还远没有结束，还有更多有意思的问题等着我们去探究。</p>
<h3 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h3><ul>
<li>[1] Martin Kleppmann,《Designing Data-Intensive Applications》, 2017.</li>
<li>[2] Martin Kleppmann, “Please Stop Calling Databases CP or AP”, 2015.</li>
<li>[3] Peter Bailis, Ali Ghodsi, “Eventual Consistency Today: Limitations, Extensions, and Beyond”, 2013.</li>
<li>[4] Werner Vogels, “Eventually Consistent”, 2008.</li>
<li>[5] Prince Mahajan, Lorenzo Alvisi, Mike Dahlin, “Consistency, Availability, and Convergence”, 2011.</li>
<li>[6] Peter Bailis, Ali Ghodsi, et al, “Bolt-on Causal Consistency”, 2013.</li>
<li>[7] Mustaque Ahamad, Gil Neiger, James E. Burns, et al, “Causal Memory: Definitions, Implementation and Programming”, 1994.</li>
<li>[8] Leslie Lamport, “Time, Clocks, and the Ordering of Events in a Distributed System”, 1978.</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Peng Chen</p>
  <div class="site-description" itemprop="description">彭晨的简单记录</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">85</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="mailto:772307865@qq.com" title="E-Mail → mailto:772307865@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Peng Chen</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  


</body>
</html>
